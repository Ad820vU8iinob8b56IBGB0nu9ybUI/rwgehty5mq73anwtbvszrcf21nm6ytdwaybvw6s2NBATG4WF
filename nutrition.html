<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-AR">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FitTrack AI | Nutrition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Added for barcode scanning -->
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    <style>
        :root {
            --background: #000000;
            --primary-text: #eaeaea;
            --secondary-text: #888888;
            --card-bg: #111111;
            --input-bg: #191919;
            --border-color: #222222;
            --accent: #FFFFFF;
            --accent-hover: #DDDDDD;
            --danger: #E53E3E;
            --edit: #3b82f6;
            --nav-footer-height: 64px; /* Set height of the new fixed footer nav */
        }

        html, body {
            overscroll-behavior-y: contain;
            /* Ensure content has room above the fixed footer */
            padding-bottom: var(--nav-footer-height);
        }

        body {
            background-color: var(--background);
            color: var(--primary-text);
            font-family: 'Manrope', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        h1, h2, h3, h4, h5, h6 {
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .nav-link {
            /* Styles for the footer navigation links */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex-grow: 1;
            height: 100%;
            transition: color 0.3s ease;
            color: var(--secondary-text);
            font-size: 0.75rem;
            text-decoration: none;
            padding-top: 4px;
        }

        .nav-link:hover {
            color: var(--primary-text);
        }

        .nav-link.active {
            color: var(--primary-text);
        }

        .nav-link.active .nav-icon {
            color: var(--primary-text);
        }

        .nav-icon {
            margin-bottom: 2px;
            width: 24px;
            height: 24px;
        }

        #mobile-footer-nav {
            background-color: var(--card-bg); /* Ensure it is fully opaque */
        }

        .content-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 1.5rem;
        }

        .form-input {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            color: var(--primary-text);
            padding: 0.75rem 1rem;
            width: 100%;
            transition: all 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
        }

        .form-input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .form-label {
            color: var(--secondary-text);
            font-size: 0.875rem;
            font-weight: 500;
        }

        .btn {
            border-radius: 0.5rem;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            transition: all 0.2s ease-in-out;
            text-align: center;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            transform: translateY(0);
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: translateY(0);
        }

        /* NEW: Water Button Styles */
        #add-water-btn {
            position: relative;
            overflow: hidden;
            /* Ensure gestures are captured */
            touch-action: none; 
        }
        #water-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            background-color: #3b82f6; /* Blue fill */
            height: 0%; /* Starts at 0 */
            transition: height 0.3s ease-out;
            z-index: 1;
        }
        #add-water-btn > i {
            position: relative;
            z-index: 2;
             /* Add a subtle shadow to make icon pop */
            filter: drop-shadow(0 1px 1px rgba(0,0,0,0.4));
        }
        /* END: Water Button Styles */

        .btn-primary {
            background-color: var(--accent);
            color: var(--background);
        }

        .btn-primary:hover:not(:disabled) {
            background-color: var(--accent-hover);
        }

        .btn-secondary {
            background-color: transparent;
            border: 1px solid var(--border-color);
            color: var(--primary-text);
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: var(--border-color);
            border-color: var(--accent);
        }

        .btn-danger {
            background-color: var(--danger);
            color: var(--primary-text);
        }

        .btn-danger:hover:not(:disabled) {
             background-color: #C53030;
        }

        .modal-backdrop {
            display: none;
            position: fixed;
            z-index: 50;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease;
            /* Added for mobile full-screen modals */
            padding: 0;
        }

        /* Standard modal content */
        .modal-content {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            padding: 2rem;
            border-radius: 0.75rem;
            width: 90%;
            max-width: 550px;
            max-height: 90vh;
            overflow-y: auto;
            animation: slideIn 0.3s ease;
        }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideIn { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

        .loader {
            border: 2px solid #333;
            border-top: 2px solid var(--accent);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: var(--input-bg); border-radius: 3px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #666; }

        details > summary { list-style: none; }
        details > summary::-webkit-details-marker { display: none; }

        /* Style for details summary */
        details summary {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding-bottom: 0.5rem;
        }
        details summary .chevron {
            transition: transform 0.2s ease;
        }
        details[open] summary .chevron {
            transform: rotate(180deg);
        }


        /* Prevents number input arrows */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
          -webkit-appearance: none;
          margin: 0;
        }
        input[type=number] {
          -moz-appearance: textfield;
        }

        /* Swipe gesture styles */
        .swipe-item {
            position: relative;
            overflow: hidden;
            user-select: none;
        }
        .swipe-actions {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
        }
        .swipe-action-container {
            position: absolute;
            top: 0; bottom: 0;
            width: 100%;
            display: flex;
            align-items: center;
            opacity: 0; /* Hidden by default */
            transition: opacity 0.3s ease;
        }
        .swipe-action-container.left { /* Delete */
            justify-content: flex-start;
            background: linear-gradient(to right, hsl(0, 72%, 51%), hsl(0, 82%, 61%));
        }
        .swipe-action-container.right { /* Edit */
            justify-content: flex-end;
            background: linear-gradient(to left, hsl(217, 91%, 60%), hsl(217, 81%, 70%));
        }
        .swipe-actions .action {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            padding: 0 1.5rem;
        }
        .swipe-content {
            position: relative;
            background-color: var(--card-bg); /* Use card background for swipable item */
            touch-action: pan-y; /* Allow vertical scroll while capturing horizontal */
            cursor: pointer;
        }
        .swipe-content.swiping {
            transition: none; /* No transition while actively dragging */
        }
        .swipe-content.returning {
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* Carousel Styles */
        .carousel-wrapper {
            position: relative;
            width: 100%;
            margin: 0 auto;
        }
        .carousel-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
            background-color: rgba(17, 17, 17, 0.7);
            color: var(--primary-text);
            border: 1px solid var(--border-color);
            border-radius: 9999px;
            width: 2.5rem;
            height: 2.5rem;
            display: none; /* Initially hidden, controlled by JS */
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
            cursor: pointer;
        }
        .carousel-btn:hover {
            background-color: var(--input-bg);
        }
        /* Adjusted positioning for better tap targets */
        .carousel-prev { left: -0.75rem; }
        .carousel-next { right: -0.75rem; }

        .horizontal-scroll-container {
            display: flex;
            overflow-x: auto;
            scroll-behavior: smooth;
            scroll-snap-type: x mandatory;
            gap: 1rem;
            padding-top: 1rem;
            padding-bottom: 1rem;
            /* Hide scrollbars */
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .horizontal-scroll-container::-webkit-scrollbar {
            display: none;
        }
        .scroll-item {
            flex: 0 0 85%; /* Default item width */
            width: 85%;
            scroll-snap-align: center;
            white-space: normal;
        }
        /* Centering padding */
        .horizontal-scroll-container::before,
        .horizontal-scroll-container::after {
            content: '';
            /* Adjust width calculation based on the default item width (85%) */
            width: calc((100% - 85%) / 2 - 0.5rem);
            flex-shrink: 0;
        }

        /* Wider items for scanner carousels */
        .scanner-carousel .scroll-item {
            flex: 0 0 95%; /* Make scanner items wider */
            width: 95%;
        }
        .scanner-carousel::before,
        .scanner-carousel::after {
             /* Adjust width calculation based on the scanner item width (95%) */
            width: calc((100% - 95%) / 2 - 0.5rem);
        }

    </style>
</head>
<body class="antialiased">

    <div class="container mx-auto max-w-7xl px-4 py-8">
        <!-- Header -->
        <header class="flex items-center justify-between mb-8 pb-4 border-b border-gray-900">
            <a href="index.html" class="flex items-center gap-3">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white"><path d="m6.5 6.5 11 11"/><path d="m21 21-1-1"/><path d="m3 3 1 1"/><path d="m18 22 4-4"/><path d="m6 2 4 4"/><path d="m3 10.5 4.5-4.5"/><path d="m13.5 21 4.5-4.5"/></svg>
                <h1 class="text-2xl font-bold">FitTrack AI</h1>
            </a>
        </header>
        <!-- Main Content -->
        <main class="grid grid-cols-1 md:grid-cols-2 gap-8">
             <!-- Left Column: Summary -->
            <div class="space-y-8">
                <div id="daily-summary-card" class="content-card">
                    <!-- Date Navigation & Chart -->
                    <div class="flex items-center justify-between mb-4">
                        <div class="text-left">
                            <h3 class="text-xl font-bold">
                                <span id="day-view-title-span" class="block text-2xl font-semibold cursor-pointer">Today</span>
                                <span id="day-view-date-span" class="text-base text-secondary-text cursor-pointer"></span>
                            </h3>
                        </div>
                        <div class="w-16 h-16">
                            <canvas id="macro-chart"></canvas>
                        </div>
                    </div>
                    <div class="w-full grid grid-cols-2 gap-x-6 gap-y-2 text-xs sm:text-sm">
                        <div class="flex justify-between items-baseline"><span class="text-gray-400">Calories:</span> <span class="font-semibold"><span id="current-calories">0</span> / <span id="goal-calories">2000</span></span></div>
                        <div class="flex justify-between items-baseline"><span class="text-gray-400">Protein:</span> <span class="font-semibold"><span id="current-protein">0</span> / <span id="goal-protein">150</span> g</span></div>
                        <div class="flex justify-between items-baseline"><span class="text-gray-400">Carbs:</span> <span class="font-semibold"><span id="current-carbs">0</span> / <span id="goal-carbs">225</span> g</span></div>
                        <div class="flex justify-between items-baseline"><span class="text-gray-400">Fat:</span> <span class="font-semibold"><span id="current-fat">0</span> / <span id="goal-fat">60</span> g</span></div>
                        <div class="flex justify-between items-baseline"><span class="text-gray-400">Na:</span> <span class="font-semibold"><span id="current-sodium">0</span> / <span id="goal-sodium">2300</span> mg</span></div>
                        <div class="flex justify-between items-baseline"><span class="text-gray-400">K:</span> <span class="font-semibold"><span id="current-potassium">0</span> / <span id="goal-potassium">3500</span> mg</span></div>
                        <div class="flex justify-between items-baseline"><span class="text-gray-400">Sugar:</span> <span class="font-semibold"><span id="current-sugar">0</span> / <span id="goal-sugar">50</span> g</span></div>
                        <div class="flex justify-between items-baseline"><span class="text-gray-400">Water:</span> <span class="font-semibold"><span id="current-water">0</span> / <span id="goal-water">2500</span> ml</span></div>
                    </div>
                </div>
            </div>
            <!-- Right Column: Logging & Food Log -->
            <div class="space-y-8">
                <div class="content-card">
                    <h3 class="text-2xl font-bold mb-6">Log Your Meal</h3>
                    <form id="log-meal-form" class="space-y-4">
                        <div>
                            <label for="food-name-input" class="form-label">Food Name *</label>
                            <input type="text" id="food-name-input" list="favorite-foods-datalist" placeholder="e.g., Chicken Breast" class="form-input mt-1">
                            <datalist id="favorite-foods-datalist"></datalist>
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label for="food-servings-input" class="form-label">Servings *</label>
                                <input type="number" id="food-servings-input" placeholder="1" value="1" min="0" step="0.1" class="form-input mt-1">
                            </div>
                            <div>
                                <label for="food-brand-input" class="form-label">Brand (Optional)</label>
                                <input type="text" id="food-brand-input" placeholder="e.g., Tesco" class="form-input mt-1">
                            </div>
                        </div>
                        <details class="pt-2">
                            <summary class="cursor-pointer text-sm text-gray-400 hover:text-white flex items-center justify-between">
                                <span>Enter Macros for 1 Serving</span>
                                <i data-lucide="chevron-down" class="w-4 h-4 chevron"></i>
                            </summary>
                            <div class="space-y-3 pt-4 mt-4 border-t border-gray-800">
                                <div class="grid grid-cols-4 gap-2">
                                    <div>
                                        <label class="form-label text-xs">Calories</label>
                                        <input type="number" step="0.01" id="food-calories-input" min="0" placeholder="kcal" class="form-input mt-1 !py-1.5 text-sm macro-input">
                                    </div>
                                    <div>
                                        <label class="form-label text-xs">Protein</label>
                                        <input type="number" step="0.01" id="food-protein-input" min="0" placeholder="g" class="form-input mt-1 !py-1.5 text-sm macro-input">
                                    </div>
                                    <div>
                                        <label class="form-label text-xs">Fat</label>
                                        <input type="number" step="0.01" id="food-fat-input" min="0" placeholder="g" class="form-input mt-1 !py-1.5 text-sm macro-input">
                                    </div>
                                    <div>
                                        <label class="form-label text-xs">Carbs</label>
                                        <input type="number" step="0.01" id="food-carbs-input" min="0" placeholder="g" class="form-input mt-1 !py-1.5 text-sm macro-input">
                                    </div>
                                </div>
                                <div class="grid grid-cols-4 gap-2">
                                    <div>
                                        <label class="form-label text-xs">Sugar</label>
                                        <input type="number" step="0.01" id="food-sugar-input" min="0" placeholder="g" class="form-input mt-1 !py-1.5 text-sm macro-input">
                                    </div>
                                    <div>
                                        <label class="form-label text-xs">Potassium</label>
                                        <input type="number" step="0.01" id="food-potassium-input" min="0" placeholder="mg" class="form-input mt-1 !py-1.5 text-sm macro-input">
                                    </div>
                                    <div>
                                        <label class="form-label text-xs">Sodium</label>
                                        <input type="number" step="0.01" id="food-sodium-input" min="0" placeholder="mg" class="form-input mt-1 !py-1.5 text-sm macro-input">
                                    </div>
                                    <div>
                                        <label for="food-grams-input" class="form-label text-xs">Grams</label>
                                        <input type="number" id="food-grams-input" placeholder="g" min="0" class="form-input mt-1 !py-1.5 text-sm">
                                    </div>
                                </div>
                            </div>
                        </details>
                        <!-- Updated Button Grid -->
                        <div class="grid grid-cols-4 gap-2 sm:gap-4 pt-6">
                            <!-- Combined Scan Button -->
                            <button id="scan-combined-btn" type="button" class="btn btn-secondary !p-2 sm:!p-3" title="Scan Barcode or Food"><i data-lucide="scan-line" class="w-4 h-4 sm:w-5 sm:h-5"></i></button>
                            <!-- NEW: AI Macro Swap Button -->
                            <button id="ai-macro-swap-btn" type="button" class="btn btn-secondary !p-2 sm:!p-3" title="AI Macro Swap">
                                <i data-lucide="replace" class="w-4 h-4 sm:w-5 sm:h-5 btn-text"></i>
                                <div class="loader hidden"></div>
                            </button>
                            <!-- Add Food (AI Lookup) Button -->
                            <button id="add-food-btn" type="button" class="btn btn-primary !p-2 sm:!p-3" title="Add Food / AI Lookup">
                                <i data-lucide="sparkles" class="w-4 h-4 sm:w-5 sm:h-5 btn-text"></i>
                                <div class="loader hidden"></div>
                            </button>
                            <!-- Log Water Button -->
                            <button id="add-water-btn" type="button" class="btn btn-secondary !p-2 sm:!p-3" title="Log Water (Tap, Swipe Up/Down, Swipe Left/Right)">
                                <span id="water-fill"></span> <!-- New fill element -->
                                <i data-lucide="glass-water" class="w-4 h-4 sm:w-5 sm:h-5"></i>
                            </button>
                        </div>
                        <div id="add-food-error" class="text-red-400 text-sm mt-2 h-4"></div>
                    </form>
                </div>
                <!-- Daily Log Content & AI Report Output -->
                <div class="content-card">
                     <div class="flex justify-between items-center mb-4">
                         <h3 class="text-2xl font-bold">Food Log</h3>
                         <div class="flex items-center gap-2">
                             <button id="ai-daily-report-btn" class="btn btn-secondary !p-2" title="Get Daily AI Report">
                                 <i data-lucide="clipboard-list" class="w-5 h-5 btn-text"></i>
                                 <div class="loader hidden !w-5 !h-5"></div>
                             </button>
                             <button id="ai-meal-suggester-btn" class="btn btn-secondary !p-2" title="AI Meal Suggester"><i data-lucide="lightbulb" class="w-5 h-5"></i></button>
                             <button id="open-nutritionist-chat-btn" class="btn btn-secondary !p-2" title="Chat with AI Nutritionist"><i data-lucide="message-circle" class="w-5 h-5"></i></button>
                         </div>
                    </div>
                    <div id="daily-log-content" class="space-y-2 max-h-60 overflow-y-auto custom-scrollbar pr-2"><p class="text-gray-500">No food logged yet.</p></div>
                </div>
                <!-- Favorites & Recipes -->
                <div class="content-card">
                    <h3 class="text-2xl font-bold mb-4">Favorites & Recipes</h3>
                    <div id="saved-items-list" class="space-y-2 max-h-60 overflow-y-auto custom-scrollbar pr-2"><p class="text-gray-500 text-center">No saved items yet.</p></div>
                </div>
            </div>
        </main>
    </div>

    <!-- Modals -->
    <!-- REMOVED Combined Scanner Chooser Modal -->

    <!-- Renamed and Unified AI Scanner Modal (was food-scanner-modal) -->
    <div id="ai-scanner-modal" class="modal-backdrop" style="z-index: 60;">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold">AI Scanner</h2>
                <button id="close-ai-scanner-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <div class="space-y-4">
                <div id="ai-scanner-initial-options" class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <label for="ai-upload-photo-input" class="btn btn-secondary cursor-pointer"><i data-lucide="upload"></i>Upload (Food or Barcode)</label>
                    <input type="file" id="ai-upload-photo-input" class="hidden" accept="image/*" multiple>
                    <button id="start-ai-camera-btn" class="btn bg-white text-black hover:bg-gray-200"><i data-lucide="camera"></i>Start Live Camera</button>
                </div>
                <div id="ai-live-camera-container" class="hidden space-y-2">
                    <video id="ai-camera-video" class="w-full rounded-lg border border-border-color" autoplay playsinline></video>
                    <canvas id="ai-camera-canvas" class="hidden"></canvas> <!-- For capturing frames -->
                    <button id="capture-ai-photo-btn" class="btn btn-primary w-full">Capture Photo</button>
                    <button id="stop-ai-camera-btn" class="btn btn-danger w-full">Close Camera</button>
                </div>
                <!-- This status text was missing in your file, re-adding it -->
                <p id="ai-scanner-status" class="text-center text-secondary-text text-sm min-h-[1.25rem]"></p>
                <div id="ai-scanner-carousel-wrapper" class="carousel-wrapper hidden">
                    <button id="ai-scanner-prev" type="button" class="carousel-btn carousel-prev"><i data-lucide="chevron-left"></i></button>
                    <div id="ai-scanner-results-container" class="horizontal-scroll-container scanner-carousel mt-4 min-h-[220px]">
                        <!-- Results injected here -->
                    </div>
                    <button id="ai-scanner-next" type="button" class="carousel-btn carousel-next"><i data-lucide="chevron-right"></i></button>
                </div>
                <!-- This was the end of the scanner results container -->
                </div>
            </div>
        </div>
    </div>

    <!-- START: RE-ADDED MODALS -->

    <!-- AI Nutritionist Chat Modal -->
    <div id="ai-nutritionist-modal" class="modal-backdrop" style="z-index: 70;">
        <div class="modal-content !h-[90vh] !max-h-[800px] flex flex-col">
            <div class="flex justify-between items-center mb-4 pb-4 border-b border-border-color">
                <h2 class="text-2xl font-bold flex items-center gap-2"><i data-lucide="bot" class="w-6 h-6 text-blue-400"></i>AI Nutritionist</h2>
                <button id="close-ai-nutritionist-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <div id="ai-chat-history" class="flex-grow overflow-y-auto space-y-4 pr-2 custom-scrollbar">
                <!-- Chat history will be rendered here -->
            </div>
            <div class="mt-4 pt-4 border-t border-border-color flex gap-2">
                <input type="text" id="ai-chat-input" class="form-input flex-grow" placeholder="Ask about your diet...">
                <button id="ai-chat-send-btn" class="btn btn-primary !p-3"><i data-lucide="send" class="w-5 h-5"></i></button>
            </div>
        </div>
    </div>

    <!-- Edit Favorite Modal -->
    <div id="edit-favorite-modal" class="modal-backdrop">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">Edit Favorite Food</h2>
                <button id="close-edit-favorite-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <form id="edit-favorite-form" class="space-y-4">
                <div>
                    <label for="edit-fav-food-name" class="form-label">Food Name (100g serving)</label>
                    <input type="text" id="edit-fav-food-name" class="form-input mt-1" required>
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label for="edit-fav-food-calories" class="form-label">Calories</label>
                        <input type="number" step="0.01" id="edit-fav-food-calories" class="form-input mt-1" required>
                    </div>
                    <div>
                        <label for="edit-fav-food-protein" class="form-label">Protein (g)</label>
                        <input type="number" step="0.01" id="edit-fav-food-protein" class="form-input mt-1" required>
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label for="edit-fav-food-carbs" class="form-label">Carbs (g)</label>
                        <input type="number" step="0.01" id="edit-fav-food-carbs" class="form-input mt-1" required>
                    </div>
                    <div>
                        <label for="edit-fav-food-fat" class="form-label">Fat (g)</label>
                        <input type="number" step="0.01" id="edit-fav-food-fat" class="form-input mt-1" required>
                    </div>
                </div>
                <!-- Optional micronutrients -->
                <details class="pt-2">
                    <summary class="cursor-pointer text-sm text-gray-400 hover:text-white">Optional Macros (per 100g)</summary>
                    <div class="grid grid-cols-3 gap-3 pt-3">
                        <div>
                            <label for="edit-fav-food-sugar" class="form-label text-xs">Sugar (g)</label>
                            <input type="number" step="0.01" id="edit-fav-food-sugar" class="form-input mt-1 !py-1.5 text-sm">
                        </div>
                        <div>
                            <label for="edit-fav-food-sodium" class="form-label text-xs">Sodium (mg)</label>
                            <input type="number" step="0.01" id="edit-fav-food-sodium" class="form-input mt-1 !py-1.5 text-sm">
                        </div>
                        <div>
                            <label for="edit-fav-food-potassium" class="form-label text-xs">Potassium (mg)</label>
                            <input type="number" step="0.01" id="edit-fav-food-potassium" class="form-input mt-1 !py-1.5 text-sm">
                        </div>
                    </div>
                </details>
                <button type="submit" class="btn btn-primary w-full mt-4">Save Changes</button>
            </form>
        </div>
    </div>

    <!-- Generic Alert Modal -->
    <div id="alert-modal" class="modal-backdrop" style="z-index: 80;">
        <div class="modal-content">
            <h2 id="alert-modal-title" class="text-2xl font-bold mb-4">Alert</h2>
            <p id="alert-modal-text" class="text-gray-300 mb-6"></p>
            <button id="alert-modal-ok-btn" class="btn btn-primary w-full">OK</button>
        </div>
    </div>

    <!-- Generic Confirm Modal -->
    <div id="confirm-modal" class="modal-backdrop" style="z-index: 80;">
        <div class="modal-content">
            <h2 id="confirm-modal-title" class="text-2xl font-bold mb-4">Confirm</h2>
            <p id="confirm-modal-text" class="text-gray-300 mb-6"></p>
            <div class="flex gap-4">
                <button id="confirm-modal-cancel-btn" class="btn btn-secondary w-full">Cancel</button>
                <button id="confirm-modal-confirm-btn" class="btn btn-danger w-full">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Generic Prompt Modal -->
    <div id="prompt-modal" class="modal-backdrop" style="z-index: 80;">
        <div class="modal-content">
            <h2 id="prompt-modal-title" class="text-2xl font-bold mb-4">Input</h2>
            <p id="prompt-modal-text" class="text-gray-300 mb-4"></p>
            <input type="text" id="prompt-modal-input" class="form-input w-full">
            <div class="flex gap-4 mt-6">
                <button id="prompt-modal-cancel-btn" class="btn btn-secondary w-full">Cancel</button>
                <button id="prompt-modal-ok-btn" class="btn btn-primary w-full">OK</button>
            </div>
        </div>
    </div>

    <!-- AI Daily Report Modal -->
    <div id="ai-report-modal" class="modal-backdrop">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold flex items-center gap-2"><i data-lucide="clipboard-list" class="w-5 h-5 text-blue-400"></i>Daily AI Report</h2>
                <button id="close-ai-report-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <div id="ai-report-modal-text" class="text-gray-300 max-h-60 overflow-y-auto custom-scrollbar pr-2"></div>
            <button id="ai-report-modal-ok-btn" class="btn btn-primary w-full mt-6">Got it</button>
        </div>
    </div>

    <!-- AI Meal Suggester Modal -->
    <div id="ai-suggester-modal" class="modal-backdrop">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">AI Meal Suggester</h2>
                <button id="close-ai-suggester-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <p class="text-gray-400 mb-4 text-sm">Enter ingredients you have, and the AI will suggest a quick, healthy meal.</p>
            <div>
                <label for="ai-ingredients-input" class="form-label">Your Ingredients</label>
                <textarea id="ai-ingredients-input" rows="3" class="form-input mt-1" placeholder="e.g., chicken breast, rice, broccoli, olive oil"></textarea>
            </div>
            <button id="ai-suggestion-btn" class="btn btn-secondary w-full mt-4"><span class="btn-text">Generate Ideas</span><div class="loader hidden"></div></button>
            <div id="ai-suggestions-output" class="mt-4 space-y-3"></div>
        </div>
    </div>

    <!-- AI Macro Swap Modal -->
    <div id="ai-macro-swap-modal" class="modal-backdrop">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold flex items-center gap-2"><i data-lucide="replace" class="w-5 h-5 text-blue-400"></i>AI Macro Swap</h2>
                <button id="close-ai-macro-swap-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <p class="text-gray-400 mb-4 text-sm">Healthier alternatives for <strong id="ai-swap-food-name" class="text-white">...</strong></p>
            <div id="ai-macro-swap-output" class="space-y-3 min-h-[150px]">
                <!-- Suggestions will be injected here -->
                <div class="loader mx-auto"></div>
            </div>
        </div>
    </div>

    <!-- END: RE-ADDED MODALS -->

    <!-- REMOVED: Water Log Modal -->
    <!-- <div id="water-log-modal" class="modal-backdrop"> ... </div> -->

     <!-- Undo Toast -->
    <div id="undo-toast" class="fixed bottom-20 left-1/2 -translate-x-1/2 bg-gray-800 text-white py-2 px-4 rounded-lg shadow-lg flex items-center gap-4 transform translate-y-24 opacity-0 transition-all duration-300 z-[100]">
        <span id="undo-toast-text"></span>
        <button id="undo-toast-btn" class="font-bold text-blue-400 hover:text-blue-300">Undo</button>
    </div>


    <!-- FIXED MOBILE FOOTER NAV BAR -->
    <nav id="mobile-footer-nav" class="fixed bottom-0 left-0 right-0 h-16 bg-card-bg border-t border-border-color z-50 flex justify-around items-center">
        <a href="index.html" class="nav-link">
            <i data-lucide="home" class="nav-icon"></i>
            <span>Home</span>
        </a>
        <a href="nutrition.html" class="nav-link active">
            <i data-lucide="utensils" class="nav-icon"></i>
            <span>Nutrition</span>
        </a>
        <a href="workouts.html" class="nav-link">
            <i data-lucide="dumbbell" class="nav-icon"></i>
            <span>Workouts</span>
        </a>
        <a href="sleep.html" class="nav-link">
            <i data-lucide="moon" class="nav-icon"></i>
            <span>Sleep</span>
        </a>
        <a href="settings.html" class="nav-link">
            <i data-lucide="settings" class="nav-icon"></i>
            <span>Settings</span>
        </a>
    </nav>

    <!-- Hidden helper for html5-qrcode library -->
    <div id="barcode-reader-hidden-helper" class="hidden"></div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- STATE MANAGEMENT ---
            let allDailyLogs = {};
            let goals = { calories: 2000, protein: 150, carbs: 225, fat: 60, sugar: 50, sodium: 2300, potassium: 3500, water: 2500 };
            let userProfile = { goal: 'maintain weight', waterServingSize: 250 };
            let favoriteFoods = [];
            let savedRecipes = [];
            let editingFoodLogIndex = null;
            let editingFavoriteFoodName = null;
            // let editingRecipeIndex = null; // Removed recipe edit state
            let confirmCallback = null;
            let promptCallback = null;
            let viewDate = new Date();
            viewDate.setHours(0, 0, 0, 0);
            // let html5QrCode; // No longer needed as a global
            let foodCameraStream = null;
            let aiBaseMacros = null;
            let chatHistory = [];
            let lastScannedBarcode = { code: null, time: 0 };
            let undoTimeout = null;
            let lastAction = null;
            let lastWaterLogAmount = 0; // NEW: Store last water amount for undo
            let openModalCount = 0;

            // --- CORE & HELPER FUNCTIONS ---
            function dateToKey(date) { return date.toISOString().split('T')[0]; }
            function capitalizeWords(str) { if (!str) return ''; return str.replace(/\b\w/g, char => char.toUpperCase()); }

            function getDayLog(date) {
                const key = dateToKey(date);
                if (!allDailyLogs[key]) {
                    allDailyLogs[key] = { entries: [], water: 0 };
                }
                return allDailyLogs[key];
            }

            function getCurrentDayLogEntries() { return getDayLog(viewDate).entries; }

            // --- GEMINI API ---
            const getApiUrl = (model, action = 'generateContent') => {
                 const apiKey = "AIzaSyDY48xF1byvU05kS9qKvN8iyrIR3hheP8w"; // Leave empty for Canvas environment
                 return `https://generativelanguage.googleapis.com/v1beta/models/${model}:${action}?key=${apiKey}`;
            };

            // Helper function to make API calls with exponential backoff
            async function fetchWithBackoff(apiUrl, payload, maxRetries = 3) {
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (response.ok) {
                            const result = await response.json();
                           // Check for expected data in the response structure
                            const hasText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                            const hasImageData = result.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                            const hasStructuredResponse = payload.generationConfig?.responseMimeType === "application/json";

                           if (hasText || hasImageData || hasStructuredResponse) {
                                return result; // Successful and valid response structure
                            } else {
                                console.warn("API response structure unexpected, but status OK:", result);
                                if (i === maxRetries - 1) throw new Error("Invalid API response format after retries.");
                                // Continue retrying if format is wrong, unless last attempt
                            }
                        } else if (response.status === 429 || response.status >= 500) { // Retry on rate limit or server errors
                            if (i === maxRetries - 1) throw new Error(`API Error: ${response.status} after ${maxRetries} attempts.`);
                            const delay = Math.pow(2, i) * 1000 + Math.random() * 1000; // Exponential backoff with jitter
                            await new Promise(resolve => setTimeout(resolve, delay));
                        } else { // Don't retry for other client errors (4xx)
                            throw new Error(`API Error: ${response.status}`);
                        }
                    } catch (error) {
                        console.error(`Fetch attempt ${i + 1} failed:`, error);
                        if (i === maxRetries - 1) throw error; // Re-throw final error
                        const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
                throw new Error("API call failed after all retries.");
            }
            // --- END GEMINI API ---

            // --- Modal show/hide functions ---
            function showModal(modalElement) {
                modalElement.style.display = 'flex';
                if (openModalCount === 0) {
                    document.body.style.overflow = 'hidden';
                }
                openModalCount++;
            }
            function hideModal(modalElement) {
                modalElement.style.display = 'none';
                openModalCount--;
                if (openModalCount <= 0) {
                    document.body.style.overflow = '';
                    openModalCount = 0; // Failsafe
                }
            }
            // --- END Modal functions ---

            function showCustomAlert(title, text) { if (ui.alertModal.style.display === 'flex') return; ui.alertModalTitle.textContent = title; ui.alertModalText.textContent = text; showModal(ui.alertModal); }
            function showConfirmModal(title, text, onConfirm) { if (ui.confirmModal.style.display === 'flex') return; ui.confirmModalTitle.textContent = title; ui.confirmModalText.textContent = text; confirmCallback = onConfirm; showModal(ui.confirmModal); }
            function showPromptModal(title, text, defaultValue, onConfirm) { if (ui.promptModal.style.display === 'flex') return; ui.promptModalTitle.textContent = title; ui.promptModalText.textContent = text; ui.promptModalInput.value = defaultValue; promptCallback = onConfirm; showModal(ui.promptModal); ui.promptModalInput.focus(); ui.promptModalInput.select(); }

            function saveData() {
                localStorage.setItem('fitTrackAI_allDailyLogs', JSON.stringify(allDailyLogs));
                localStorage.setItem('fitTrackAI_userProfile', JSON.stringify(userProfile));
                localStorage.setItem('fitTrackAI_favoriteFoods', JSON.stringify(favoriteFoods));
                localStorage.setItem('fitTrackAI_savedRecipes', JSON.stringify(savedRecipes));
                localStorage.setItem('fitTrackAI_goals', JSON.stringify(goals));
                localStorage.setItem('fitTrackAI_chatHistory', JSON.stringify(chatHistory));
            }

            function loadData() {
                let logs = JSON.parse(localStorage.getItem('fitTrackAI_allDailyLogs')) || {};
                // Migration for old data structure
                for(const date in logs) {
                    if(Array.isArray(logs[date])) {
                        logs[date] = {
                            entries: logs[date].filter(item => item.name !== 'Water'), // Remove old water entries
                            water: 0
                        }
                    }
                }
                allDailyLogs = logs;

                chatHistory = JSON.parse(localStorage.getItem('fitTrackAI_chatHistory')) || [];
                userProfile = JSON.parse(localStorage.getItem('fitTrackAI_userProfile')) || { goal: 'maintain weight', waterServingSize: 250 };
                goals = JSON.parse(localStorage.getItem('fitTrackAI_goals')) || { calories: 2000, protein: 150, carbs: 225, fat: 60, sugar: 50, sodium: 2300, potassium: 3500, water: 2500 };
                savedRecipes = JSON.parse(localStorage.getItem('fitTrackAI_savedRecipes')) || [];
                favoriteFoods = JSON.parse(localStorage.getItem('fitTrackAI_favoriteFoods')) || [];
            }

            // --- UI ELEMENT DEFINITIONS ---
            const ui = {
                foodNameInput: document.getElementById('food-name-input'), foodBrandInput: document.getElementById('food-brand-input'), foodServingsInput: document.getElementById('food-servings-input'), foodGramsInput: document.getElementById('food-grams-input'), logMealForm: document.getElementById('log-meal-form'), addFoodBtn: document.getElementById('add-food-btn'), addFoodError: document.getElementById('add-food-error'), dailyLogContentDiv: document.getElementById('daily-log-content'),
                
                // Renamed AI Scanner Modal elements
                foodScannerModal: document.getElementById('ai-scanner-modal'), // Kept old name for compatibility, points to new ID
                closeFoodScannerModalBtn: document.getElementById('close-ai-scanner-modal-btn'),
                uploadPhotoInput: document.getElementById('ai-upload-photo-input'),
                scannerResultsContainer: document.getElementById('ai-scanner-results-container'),
                foodScannerStatus: document.getElementById('ai-scanner-status'),

                confirmModal: document.getElementById('confirm-modal'), confirmModalTitle: document.getElementById('confirm-modal-title'), confirmModalText: document.getElementById('confirm-modal-text'), confirmModalCancelBtn: document.getElementById('confirm-modal-cancel-btn'), confirmModalConfirmBtn: document.getElementById('confirm-modal-confirm-btn'), alertModal: document.getElementById('alert-modal'), alertModalTitle: document.getElementById('alert-modal-title'), alertModalText: document.getElementById('alert-modal-text'), alertModalOkBtn: document.getElementById('alert-modal-ok-btn'), 
                
                // createRecipeBtn: document.getElementById('create-recipe-btn'), // Removed
                aiMacroSwapBtn: document.getElementById('ai-macro-swap-btn'), // Added

                savedItemsListDiv: document.getElementById('saved-items-list'), promptModal: document.getElementById('prompt-modal'), promptModalTitle: document.getElementById('prompt-modal-title'), promptModalText: document.getElementById('prompt-modal-text'), promptModalInput: document.getElementById('prompt-modal-input'), promptModalCancelBtn: document.getElementById('prompt-modal-cancel-btn'), promptModalOkBtn: document.getElementById('prompt-modal-ok-btn'), editFavoriteModal: document.getElementById('edit-favorite-modal'), closeEditFavoriteModalBtn: document.getElementById('close-edit-favorite-modal-btn'), editFavoriteForm: document.getElementById('edit-favorite-form'), dailySummaryCard: document.getElementById('daily-summary-card'), dayViewTitleSpan: document.getElementById('day-view-title-span'), dayViewDateSpan: document.getElementById('day-view-date-span'), aiDailyReportBtn: document.getElementById('ai-daily-report-btn'),
                aiReportModal: document.getElementById('ai-report-modal'), aiReportModalText: document.getElementById('ai-report-modal-text'), closeAiReportModalBtn: document.getElementById('close-ai-report-modal-btn'), aiReportModalOkBtn: document.getElementById('ai-report-modal-ok-btn'),
                addWaterBtn: document.getElementById('add-water-btn'),
                waterFill: document.getElementById('water-fill'), // NEW: Water fill UI
                
                // Removed Barcode Modal elements
                // barcodeScannerModal: document.getElementById('barcode-scanner-modal'), 
                // closeBarcodeScannerModalBtn: document.getElementById('close-barcode-scanner-modal-btn'), 
                // barcodeReader: document.getElementById('barcode-reader'), 
                // barcodeScannerStatus: document.getElementById('barcode-scanner-status'), 
                // barcodeResults: document.getElementById('barcode-results'),

                openNutritionistChatBtn: document.getElementById('open-nutritionist-chat-btn'), aiNutritionistModal: document.getElementById('ai-nutritionist-modal'), closeAiNutritionistModalBtn: document.getElementById('close-ai-nutritionist-modal-btn'), aiChatHistory: document.getElementById('ai-chat-history'), aiChatInput: document.getElementById('ai-chat-input'), aiChatSendBtn: document.getElementById('ai-chat-send-btn'),
                
                // More renamed AI Scanner elements
                foodScannerInitialOptions: document.getElementById('ai-scanner-initial-options'),
                liveCameraContainer: document.getElementById('ai-live-camera-container'),
                startFoodCameraBtn: document.getElementById('start-ai-camera-btn'),
                stopFoodCameraBtn: document.getElementById('stop-ai-camera-btn'),
                captureFoodPhotoBtn: document.getElementById('capture-ai-photo-btn'),
                foodCameraVideo: document.getElementById('ai-camera-video'),
                foodCameraCanvas: document.getElementById('ai-camera-canvas'),
                
                // Removed manual barcode elements
                // manualBarcodeSubmit: document.getElementById('manual-barcode-submit'),
                // manualBarcodeInput: document.getElementById('manual-barcode-input'),

                aiMealSuggesterBtn: document.getElementById('ai-meal-suggester-btn'),
                aiSuggesterModal: document.getElementById('ai-suggester-modal'),
                closeAiSuggesterModalBtn: document.getElementById('close-ai-suggester-modal-btn'),
                aiIngredientsInput: document.getElementById('ai-ingredients-input'),
                aiSuggestionBtn: document.getElementById('ai-suggestion-btn'),
                aiSuggestionsOutput: document.getElementById('ai-suggestions-output'),
                undoToast: document.getElementById('undo-toast'),
                undoToastBtn: document.getElementById('undo-toast-btn'),
                undoToastText: document.getElementById('undo-toast-text'),
                // Carousel Buttons
                foodScannerCarouselWrapper: document.getElementById('ai-scanner-carousel-wrapper'),
                foodScannerPrev: document.getElementById('ai-scanner-prev'),
                foodScannerNext: document.getElementById('ai-scanner-next'),
                
                // Removed Barcode Carousel buttons
                // barcodeScannerCarouselWrapper: document.getElementById('barcode-scanner-carousel-wrapper'),
                // barcodeScannerPrev: document.getElementById('barcode-scanner-prev'),
                // barcodeScannerNext: document.getElementById('barcode-scanner-next'),

                // Removed chooser modal elements
                scanCombinedBtn: document.getElementById('scan-combined-btn'),
                // combinedScannerChooserModal: document.getElementById('combined-scanner-chooser-modal'),
                // chooserScanBarcodeBtn: document.getElementById('chooser-scan-barcode-btn'),
                // chooserScanFoodBtn: document.getElementById('chooser-scan-food-btn'),
                // chooserScanCancelBtn: document.getElementById('chooser-scan-cancel-btn'),

                // Added AI Macro Swap Modal
                aiMacroSwapModal: document.getElementById('ai-macro-swap-modal'),
                closeAiMacroSwapModalBtn: document.getElementById('close-ai-macro-swap-modal-btn'),
                aiMacroSwapOutput: document.getElementById('ai-macro-swap-output'),
                aiSwapFoodName: document.getElementById('ai-swap-food-name'),

                // REMOVED: Water Log Modal UI elements
                // waterLogModal: document.getElementById('water-log-modal'),
                // closeWaterLogModalBtn: document.getElementById('close-water-log-modal-btn'),
                // waterModalCurrent: document.getElementById('water-modal-current'),
                // waterModalAddDefaultBtn: document.getElementById('water-modal-add-default-btn'),
                // waterModalAdd500Btn: document.getElementById('water-modal-add-500-btn'),
                // waterModalRemoveDefaultBtn: document.getElementById('water-modal-remove-default-btn'),
                // waterModalRemove500Btn: document.getElementById('water-modal-remove-500-btn'),
                // waterModalSetTotalInput: document.getElementById('water-modal-set-total-input'),
                // waterModalSetTotalBtn: document.getElementById('water-modal-set-total-btn'),
            };

            // --- CHART.JS SETUP ---
            const macroCtx = document.getElementById('macro-chart').getContext('2d');
            let macroChart = new Chart(macroCtx, { type: 'doughnut', data: { labels: ['Protein', 'Carbs', 'Fat'], datasets: [{ data: [1, 1, 1], backgroundColor: ['#3b82f6', '#10b981', '#ef4444'], borderWidth: 0, hoverOffset: 4 }] }, options: { responsive: true, maintainAspectRatio: false, cutout: '70%', plugins: { legend: { display: false } } } });

            // --- RENDER & DATA FLOW FUNCTIONS ---
            function updateSummary() {
                const dayLog = getDayLog(viewDate);
                const currentDayLogEntries = dayLog.entries;

                const totals = currentDayLogEntries.reduce((acc, item) => { acc.calories += item.calories || 0; acc.protein += item.protein || 0; acc.carbs += item.carbs || 0; acc.fat += item.fat || 0; acc.sugar += item.sugar || 0; acc.sodium += item.sodium || 0; acc.potassium += item.potassium || 0; return acc; }, { calories: 0, protein: 0, carbs: 0, fat: 0, sugar: 0, sodium: 0, potassium: 0 });

                document.getElementById('current-calories').textContent = totals.calories.toFixed(0); document.getElementById('goal-calories').textContent = goals.calories;
                document.getElementById('current-protein').textContent = totals.protein.toFixed(1); document.getElementById('goal-protein').textContent = goals.protein;
                document.getElementById('current-carbs').textContent = totals.carbs.toFixed(1); document.getElementById('goal-carbs').textContent = goals.carbs;
                document.getElementById('current-fat').textContent = totals.fat.toFixed(1); document.getElementById('goal-fat').textContent = goals.fat;
                document.getElementById('current-sugar').textContent = totals.sugar.toFixed(1); document.getElementById('goal-sugar').textContent = goals.sugar;
                document.getElementById('current-sodium').textContent = totals.sodium.toFixed(0); document.getElementById('goal-sodium').textContent = goals.sodium;
                document.getElementById('current-potassium').textContent = totals.potassium.toFixed(0); document.getElementById('goal-potassium').textContent = goals.potassium;
                document.getElementById('current-water').textContent = dayLog.water; document.getElementById('goal-water').textContent = goals.water;

                // NEW: Update water fill
                const waterPercent = Math.min(100, (dayLog.water / (goals.water || 1)) * 100);
                if (ui.waterFill) {
                    ui.waterFill.style.height = `${waterPercent}%`;
                }

                const macroSum = totals.protein + totals.carbs + totals.fat;
                macroChart.data.datasets[0].data = macroSum > 0 ? [totals.protein, totals.carbs, totals.fat] : [1, 1, 1];
                macroChart.update();
            }

            function renderDailyLog() {
                const currentDayLogEntries = getCurrentDayLogEntries();
                if (currentDayLogEntries.length === 0) { ui.dailyLogContentDiv.innerHTML = '<p class="text-gray-500">No food logged yet.</p>'; return; }
                const isFavorite = (itemName) => favoriteFoods.some(fav => fav.name.toLowerCase() === itemName.toLowerCase()) || savedRecipes.some(rec => rec.name.toLowerCase() === itemName.toLowerCase());
                 ui.dailyLogContentDiv.innerHTML = currentDayLogEntries.map((item, index) => `
                    <div class="swipe-item rounded-lg" data-index="${index}" data-type="log" data-name="${item.name}">
                        <div class="swipe-actions">
                            <div class="swipe-action-container left"><div class="action delete"><i data-lucide="trash-2" class="pointer-events-none"></i><span class="ml-2 pointer-events-none">Delete</span></div></div>
                            <div class="swipe-action-container right"><div class="action edit"><span class="mr-2 pointer-events-none">Edit</span><i data-lucide="pencil" class="pointer-events-none"></i></div></div>
                        </div>
                        <div class="swipe-content p-3 rounded-lg border border-transparent hover:border-gray-700"> <!-- Added border for hover -->
                            <div class="flex justify-between items-center">
                                <div class="flex items-center gap-3">
                                    ${isFavorite(item.name) ? '<i data-lucide="star" class="w-4 h-4 text-yellow-400 fill-yellow-400 flex-shrink-0"></i>' : '<div class="w-4 h-4 flex-shrink-0"></div>'}
                                    <div>
                                        <p class="font-medium">${item.servings}x ${item.name} ${item.grams > 0 ? `(${item.grams.toFixed(0)}g)` : ''}</p>
                                        <p class="text-sm text-gray-400">${item.calories?.toFixed(0) || 0}kcal | ${item.protein?.toFixed(1) || 0}p | ${item.carbs?.toFixed(1) || 0}c | ${item.fat?.toFixed(1) || 0}f</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `).join('');
                lucide.createIcons();
            }

            function renderSavedItemsList() {
                const combinedList = [
                    ...savedRecipes.map((item, index) => ({...item, type: 'recipe', originalIndex: index})),
                    ...favoriteFoods.map((item, index) => ({...item, type: 'food', originalIndex: index}))
                ].sort((a,b) => a.name.localeCompare(b.name));

                if (combinedList.length === 0) {
                    ui.savedItemsListDiv.innerHTML = '<p class="text-gray-500 text-center">No saved items yet.</p>';
                    return;
                }
                const isFavorite = (itemName) => favoriteFoods.some(fav => fav.name.toLowerCase() === itemName.toLowerCase()) || savedRecipes.some(rec => rec.name.toLowerCase() === itemName.toLowerCase());

                ui.savedItemsListDiv.innerHTML = combinedList.map(item => `
                    <div class="swipe-item rounded-lg" data-name="${item.name}" data-type="${item.type}" data-index="${item.originalIndex}">
                         <div class="swipe-actions">
                            <div class="swipe-action-container left"><div class="action delete"><i data-lucide="trash-2" class="pointer-events-none"></i><span class="ml-2 pointer-events-none">Delete</span></div></div>
                            <div class="swipe-action-container right"><div class="action edit"><span class="mr-2 pointer-events-none">Edit</span><i data-lucide="pencil" class="pointer-events-none"></i></div></div>
                        </div>
                        <div class="swipe-content p-3 rounded-lg border border-transparent hover:border-gray-700"> <!-- Added border for hover -->
                            <div class="flex justify-between items-center">
                                <div class="flex items-center gap-3">
                                   ${isFavorite(item.name) ? '<i data-lucide="star" class="w-4 h-4 text-yellow-400 fill-yellow-400 flex-shrink-0"></i>' : '<div class="w-4 h-4 flex-shrink-0"></div>'}
                                   <p class="font-medium">${item.name}</p>
                                   ${item.type === 'recipe' ? '<span class="text-xs bg-blue-500 text-white rounded-full px-2 py-0.4">Recipe</span>' : ''}
                                </div>
                                <button class="log-item-btn btn btn-secondary !p-2" title="Log Item"><i data-lucide="plus" class="w-4 h-4 pointer-events-none"></i></button>
                            </div>
                        </div>
                    </div>`).join('');
                lucide.createIcons();
            }


            function fullRender() {
                updateSummary();
                renderDailyLog();
                renderSavedItemsList();
                lucide.createIcons();
            }

            // --- Recipe Modal Logic Removed ---

            // --- Existing functions for AI lookup, report generation, day view update, macros calculation ---
             async function getDailyLogAIReport() {
                const btn = ui.aiDailyReportBtn;
                if (btn.disabled) return;

                const icon = btn.querySelector('.btn-text'); // Get the icon by class
                const loader = btn.querySelector('.loader'); // Get the existing loader

                if (icon) icon.style.display = 'none'; // Hide the icon
                if (loader) loader.classList.remove('hidden'); // Show the loader
                btn.disabled = true;

                const dateKey = dateToKey(viewDate);
                const dayLog = getDayLog(viewDate);
                const currentLog = dayLog.entries;

                if (currentLog.length === 0) {
                    showCustomAlert('No Data', `There is no food logged for ${dateKey}.`);
                    if (loader) loader.classList.add('hidden'); // Hide loader
                    if (icon) icon.style.display = 'inline-block'; // Show icon
                    btn.disabled = false;
                    return;
                }

                const totals = currentLog.reduce((acc, item) => { acc.calories += item.calories || 0; acc.protein += item.protein || 0; acc.carbs += item.carbs || 0; acc.fat += item.fat || 0; acc.sugar += item.sugar || 0; acc.sodium += item.sodium || 0; acc.potassium += item.potassium || 0; return acc; }, { calories: 0, protein: 0, carbs: 0, fat: 0, sugar: 0, sodium: 0, potassium: 0 });
                const goalData = goals;

                ui.aiReportModalText.textContent = 'Generating personalized report...';
                ui.aiReportModalText.classList.remove('text-red-400');
                showModal(ui.aiReportModal);

                const systemPrompt = `You are a friendly but expert nutrition coach. Provide a brief, actionable analysis of the user's daily food log. 1. Analyze the logged data against the goals. 2. Evaluate macro distribution (Protein, Carbs, Fat) and key micronutrients (Sodium/Potassium/Sugar). 3. Provide a concise summary (1-2 sentences). 4. Offer one specific, actionable tip for improvement/maintenance based on the biggest deviation or goal. Keep the report readable, using markdown bold for key stats, and keep the total response under 100 words.`;
                const userQuery = `Analyze the following log data for ${dateKey}: --- Logged Data --- Total Calories: ${totals.calories.toFixed(0)} kcal, Protein: ${totals.protein.toFixed(1)} g, Carbs: ${totals.carbs.toFixed(1)} g, Fat: ${totals.fat.toFixed(1)} g, Sugar: ${totals.sugar.toFixed(1)} g, Sodium: ${totals.sodium.toFixed(0)} mg, Potassium: ${totals.potassium.toFixed(0)} mg. Water: ${dayLog.water} ml. --- Daily Goals --- Calorie Goal: ${goalData.calories} kcal, Protein Goal: ${goalData.protein} g, Carb Goal: ${goalData.carbs} g, Fat Goal: ${goalData.fat} g, Sugar Limit: ${goalData.sugar} g, Sodium Limit: ${goalData.sodium} mg, Potassium Target: ${goalData.potassium} mg, Water Target: ${goalData.water} ml.`;

                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                const payload = {
                     contents: [{ parts: [{ text: userQuery }] }],
                     systemInstruction: { parts: [{ text: systemPrompt }] }
                };

                try {
                    const result = await fetchWithBackoff(apiUrl, payload); // Use fetchWithBackoff
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");
                    let text = result.candidates[0].content.parts[0].text;
                    ui.aiReportModalText.innerHTML = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>');
                } catch (error) {
                    console.error("AI Report Error:", error);
                    hideModal(ui.aiReportModal);
                    // Provide a more detailed error message
                    showCustomAlert("AI Error", `Sorry, the AI coach couldn't generate a report. ${error.message}`);
                } finally {
                    btn.disabled = false;
                    if (loader) loader.classList.add('hidden'); // Hide loader
                    if (icon) icon.style.display = 'inline-block'; // Show icon
                }
            }


            function updateDayView(date) {
                viewDate = date; const today = new Date(); today.setHours(0, 0, 0, 0);
                const dateKey = dateToKey(date), isToday = dateKey === dateToKey(today);
                ui.dayViewTitleSpan.textContent = isToday ? 'Today' : date.toLocaleDateString(undefined, { weekday: 'long' });
                ui.dayViewDateSpan.textContent = date.toLocaleDateString(undefined, { month: 'long', day: 'numeric' });
                fullRender();
            }

            // Function to get macros (per 100g) using AI
            async function getMacrosFromAI(foodName, brand) {
                let prompt = `Provide nutritional information for 100g of "${foodName}"`;
                if (brand) prompt += ` from the brand "${brand}"`;
                prompt += `. Respond with only a valid JSON object containing all fields for 100 grams: "calories", "protein", "carbs", "fat", "sugar", "sodium", "potassium". Also include a "servingGrams": 100 field. If it's a food that is hard to quantify, like "salad", provide a reasonable estimate for 100g.`;

                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                const payload = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { responseMimeType: "application/json" } };
                 try {
                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");
                    return JSON.parse(result.candidates[0].content.parts[0].text);
                 } catch (error) {
                     console.error("getMacrosFromAI Error:", error);
                     throw error; // Re-throw to be caught by caller
                 }
            }

            // Function to estimate missing macros using AI
            async function getPartialMacrosFromAI(foodName, brand, knownMacros) {
                let knownMacrosString = Object.entries(knownMacros).map(([key, value]) => `${key}: ${value}`).join(', ');
                let prompt = `For a standard single serving of "${foodName}"`;
                if (brand) prompt += ` from the brand "${brand}"`;
                prompt += `, we know it has the following values: ${knownMacrosString}. Based on this, estimate the *missing* nutritional values. Respond with only a valid JSON object containing a *complete* set of fields for ONE standard serving: "servingGrams", "calories", "protein", "carbs", "fat", "sugar", "sodium", "potassium". Use the provided values as facts and fill in the rest with reasonable estimates.`;

                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                const payload = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { responseMimeType: "application/json" } };

                try {
                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");
                    return JSON.parse(result.candidates[0].content.parts[0].text);
                } catch (error) {
                    console.error("getPartialMacrosFromAI Error:", error);
                    throw error;
                }
            }
             // Function to toggle favorite status
            function toggleFavorite(itemName) {
                if (savedRecipes.some(r => r.name.toLowerCase() === itemName.toLowerCase())) {
                    showCustomAlert("Action Not Allowed", "Recipes are automatically favorited and cannot be unfavorited.");
                    return;
                }
                const favIndex = favoriteFoods.findIndex(fav => fav.name.toLowerCase() === itemName.toLowerCase());
                if (favIndex > -1) {
                    favoriteFoods.splice(favIndex, 1);
                } else {
                     const logItem = getCurrentDayLogEntries().find(item => item.name.toLowerCase() === itemName.toLowerCase()) || savedRecipes.find(item => item.name.toLowerCase() === itemName.toLowerCase());
                     if (!logItem) {
                         showCustomAlert("Error", "Could not find item to favorite.");
                         return;
                     }
                    const totalGrams = logItem.grams || 0;
                    if (totalGrams <= 0) {
                         showCustomAlert("Cannot Favorite", "Cannot favorite an item with 0 grams to calculate base macros.");
                         return;
                    }
                    // Calculate macros per 100g
                    const ratio = 100 / (totalGrams / (logItem.servings || 1)); // Correct calculation
                    favoriteFoods.push({
                        name: logItem.name,
                        calories: (logItem.calories / (logItem.servings || 1)) * ratio,
                        protein: (logItem.protein / (logItem.servings || 1)) * ratio,
                        carbs: (logItem.carbs / (logItem.servings || 1)) * ratio,
                        fat: (logItem.fat / (logItem.servings || 1)) * ratio,
                        // Add other optional macros if available in logItem
                        sugar: ((logItem.sugar || 0) / (logItem.servings || 1)) * ratio,
                        sodium: ((logItem.sodium || 0) / (logItem.servings || 1)) * ratio,
                        potassium: ((logItem.potassium || 0) / (logItem.servings || 1)) * ratio,
                     });
                }
                saveData();
                fullRender();
            }

            // Function to show undo toast
            function showUndo(type, data) {
                clearTimeout(undoTimeout);
                lastAction = { type, data };
                let text; // Declare text here
                if (type === 'delete') {
                    text = `Deleted "${data.item.name}"`;
                } else if (type === 'edit') {
                    text = `Edited "${data.originalItem.name}"`;
                } else if (type === 'water') {
                    text = `Water updated to ${data.newWater}ml`;
                }
                
                ui.undoToastText.textContent = text;
                ui.undoToast.classList.remove('translate-y-24', 'opacity-0');

                undoTimeout = setTimeout(() => {
                    hideUndo();
                }, 5000);
            }

            // Function to hide undo toast
            function hideUndo() {
                lastAction = null;
                ui.undoToast.classList.add('translate-y-24', 'opacity-0');
            }

            // --- CAROUSEL SETUP ---
            function setupCarousel(containerId, prevBtnId, nextBtnId) {
                const container = document.getElementById(containerId);
                const prevBtn = document.getElementById(prevBtnId);
                const nextBtn = document.getElementById(nextBtnId);
                const wrapper = container ? container.closest('.carousel-wrapper') : null;

                if (!container || !prevBtn || !nextBtn || !wrapper) {
                     return;
                }

                 prevBtn.style.display = 'none';
                 nextBtn.style.display = 'none';

                const scrollAmount = () => {
                    const firstItem = container.querySelector('.scroll-item');
                    return firstItem ? firstItem.offsetWidth + 16 : container.offsetWidth * 0.9;
                };

                prevBtn.onclick = () => {
                    container.scrollBy({ left: -scrollAmount(), behavior: 'smooth' });
                };

                nextBtn.onclick = () => {
                    container.scrollBy({ left: scrollAmount(), behavior: 'smooth' });
                };
            }


            // --- EVENT LISTENERS ---
            // Log Meal Form Submission / AI Lookup
            ui.addFoodBtn.addEventListener('click', async () => {
                ui.addFoodError.textContent = '';
                const btn = ui.addFoodBtn;
                const btnText = btn.querySelector('.btn-text');
                const loader = btn.querySelector('.loader');

                const foodName = capitalizeWords(ui.foodNameInput.value.trim());
                const servings = parseFloat(ui.foodServingsInput.value);

                if (!foodName || isNaN(servings) || servings <= 0) {
                    ui.addFoodError.textContent = "Please enter a valid food name and serving amount.";
                    return;
                }

                let singleServingMacros = {};
                let manualMacros = {};
                let manualMacroCount = 0;
                let hasError = false;
                const macroKeys = ['calories', 'protein', 'carbs', 'fat', 'sugar', 'sodium', 'potassium'];

                macroKeys.forEach(m => {
                    const input = document.getElementById(`food-${m}-input`);
                    const valStr = input.value.trim();
                    if (valStr !== '') {
                        const val = parseFloat(valStr);
                        if (!isNaN(val) && val < 0) {
                            ui.addFoodError.textContent = "Macro values cannot be negative.";
                            input.classList.add('!border-red-500');
                            hasError = true;
                        } else if (!isNaN(val)) {
                            input.classList.remove('!border-red-500');
                            singleServingMacros[m] = val;
                            manualMacros[m] = val;
                            manualMacroCount++;
                        }
                    } else {
                        singleServingMacros[m] = 0; // Initialize with 0 if blank
                    }
                });

                if (hasError) return;

                let servingGrams = parseFloat(ui.foodGramsInput.value) || 0;

                // AI LOGIC (Only if not editing)
                if (editingFoodLogIndex === null) {
                    if (manualMacroCount > 0 && manualMacroCount < macroKeys.length) { // SOME macros entered
                        btn.disabled = true; btnText.style.display = 'none'; loader.classList.remove('hidden');
                        try {
                            const brand = ui.foodBrandInput.value.trim();
                            const data = await getPartialMacrosFromAI(foodName, brand, manualMacros);
                            servingGrams = data.servingGrams || servingGrams || 0; // Use AI grams if available
                            // Merge AI data with manual data, prioritizing manual
                            // --- FIX START ---
                            // Original lines:
                            // singleServingMacros = {
                            //    calories: manualMacros.calories ?? data.calories ?? 0,
                            //    protein: manualMacros.protein ?? data.protein ?? 0,
                            //    carbs: manualMacros.carbs ?? data.carbs ?? 0,
                            //    fat: manualMacros.fat ?? data.fat ?? 0,
                            //    sugar: manualMacros.sugar ?? data.sugar ?? 0,
                            //    sodium: manualMacros.sodium ?? data.sodium ?? 0,
                            //    potassium: manualMacros.potassium ?? data.potassium ?? 0,
                            // };
                            // Fixed lines: Ensure AI data is parsed as float
                            singleServingMacros = {
                                calories: manualMacros.calories ?? (parseFloat(data.calories) || 0),
                                protein: manualMacros.protein ?? (parseFloat(data.protein) || 0),
                                carbs: manualMacros.carbs ?? (parseFloat(data.carbs) || 0),
                                fat: manualMacros.fat ?? (parseFloat(data.fat) || 0),
                                sugar: manualMacros.sugar ?? (parseFloat(data.sugar) || 0),
                                sodium: manualMacros.sodium ?? (parseFloat(data.sodium) || 0),
                                potassium: manualMacros.potassium ?? (parseFloat(data.potassium) || 0),
                            };
                            // --- FIX END ---
                             // Update form with completed values
                            document.getElementById('food-calories-input').value = singleServingMacros.calories.toFixed(0);
                            document.getElementById('food-protein-input').value = singleServingMacros.protein.toFixed(1);
                            document.getElementById('food-carbs-input').value = singleServingMacros.carbs.toFixed(1);
                            document.getElementById('food-fat-input').value = singleServingMacros.fat.toFixed(1);
                            document.getElementById('food-sugar-input').value = singleServingMacros.sugar.toFixed(1);
                            document.getElementById('food-sodium-input').value = singleServingMacros.sodium.toFixed(0);
                            document.getElementById('food-potassium-input').value = singleServingMacros.potassium.toFixed(0);
                            if (servingGrams > 0) ui.foodGramsInput.value = servingGrams.toFixed(0);

                        } catch (error) {
                            console.error("AI Partial Macros Error:", error);
                            ui.addFoodError.textContent = `Could not estimate missing macros. ${error.message}`;
                        } finally {
                            btn.disabled = false; btnText.style.display = 'inline-block'; loader.classList.add('hidden');
                        }
                    } else if (manualMacroCount === 0) { // NO macros entered
                        btn.disabled = true; btnText.style.display = 'none'; loader.classList.remove('hidden');
                        try {
                            const brand = ui.foodBrandInput.value.trim();
                            const data = await getMacrosFromAI(foodName, brand); // Returns 100g data
                            servingGrams = 100; // AI data is per 100g
                            // --- FIX START ---
                            // Original line:
                            // singleServingMacros = { calories: data.calories, protein: data.protein, carbs: data.carbs, fat: data.fat, sugar: data.sugar, sodium: data.sodium, potassium: data.potassium };
                            // Fixed line: Coerce all values to numbers, default to 0
                            singleServingMacros = {
                                calories: parseFloat(data.calories) || 0,
                                protein: parseFloat(data.protein) || 0,
                                carbs: parseFloat(data.carbs) || 0,
                                fat: parseFloat(data.fat) || 0,
                                sugar: parseFloat(data.sugar) || 0,
                                sodium: parseFloat(data.sodium) || 0,
                                potassium: parseFloat(data.potassium) || 0
                            };
                            // --- FIX END ---


                            // If user entered grams, scale the 100g data for the total log entry
                            const userGrams = parseFloat(ui.foodGramsInput.value);
                            if (!isNaN(userGrams) && userGrams > 0) {
                                const ratio = userGrams / 100.0;
                                servingGrams = userGrams; // Serving grams is the user input
                                // Scale the macros *for the log entry*
                                for (const key in singleServingMacros) {
                                    singleServingMacros[key] *= ratio;
                                }
                                // Fill the form with SINGLE SERVING (user grams) values
                                document.getElementById('food-calories-input').value = singleServingMacros.calories.toFixed(0);
                                document.getElementById('food-protein-input').value = singleServingMacros.protein.toFixed(1);
                                document.getElementById('food-carbs-input').value = singleServingMacros.carbs.toFixed(1);
                                document.getElementById('food-fat-input').value = singleServingMacros.fat.toFixed(1);
                                document.getElementById('food-sugar-input').value = singleServingMacros.sugar.toFixed(1);
                                document.getElementById('food-sodium-input').value = singleServingMacros.sodium.toFixed(0);
                                document.getElementById('food-potassium-input').value = singleServingMacros.potassium.toFixed(0);

                            } else {
                                // If no grams entered, fill the form with 100g data, set grams to 100
                                ui.foodGramsInput.value = servingGrams.toFixed(0);
                                document.getElementById('food-calories-input').value = singleServingMacros.calories.toFixed(0);
                                document.getElementById('food-protein-input').value = singleServingMacros.protein.toFixed(1);
                                document.getElementById('food-carbs-input').value = singleServingMacros.carbs.toFixed(1);
                                document.getElementById('food-fat-input').value = singleServingMacros.fat.toFixed(1);
                                document.getElementById('food-sugar-input').value = singleServingMacros.sugar.toFixed(1);
                                document.getElementById('food-sodium-input').value = singleServingMacros.sodium.toFixed(0);
                                document.getElementById('food-potassium-input').value = singleServingMacros.potassium.toFixed(0);
                            }

                        } catch (error) {
                            console.error("AI Get Macros Error:", error);
                             ui.addFoodError.textContent = `Could not fetch nutrition data. ${error.message}`;
                        } finally {
                            btn.disabled = false; btnText.style.display = 'inline-block'; loader.classList.add('hidden');
                        }
                    }
                } // End AI Logic Block


                if (ui.addFoodError.textContent) return; // Stop if AI errored

                // Log the food (or update if editing)
                const dayLog = getDayLog(viewDate);
                const totalMacros = {};
                 // Use the macros from singleServingMacros (which might have been updated by AI or manual input)
                macroKeys.forEach(m => {
                    totalMacros[m] = (singleServingMacros[m] || 0) * servings;
                });

                const foodItem = {
                    name: foodName,
                    brand: ui.foodBrandInput.value.trim(),
                    servings,
                    grams: servingGrams * servings, // Total grams for all servings
                    ...totalMacros
                };

                if (editingFoodLogIndex !== null) {
                    const originalItem = { ...dayLog.entries[editingFoodLogIndex] };
                    dayLog.entries[editingFoodLogIndex] = foodItem;
                    showUndo('edit', { index: editingFoodLogIndex, originalItem: originalItem });
                    editingFoodLogIndex = null;
                } else {
                    dayLog.entries.unshift(foodItem);
                }

                ui.logMealForm.reset();
                ui.foodServingsInput.value = 1; // Reset servings to 1
                saveData();
                updateDayView(viewDate); // This calls fullRender
            });

            // Log Water
            // REMOVED: Old water button listener
            // ui.addWaterBtn.addEventListener('click', () => { ... });

            // --- New Water Modal Listeners ---
            // REMOVED: All water modal listeners
            // ui.closeWaterLogModalBtn.addEventListener('click', () => hideModal(ui.waterLogModal));
            
            const updateWater = (amount, isSetTotal = false) => {
                const dayLog = getDayLog(viewDate);
                const currentWater = dayLog.water || 0;
                let originalWater = currentWater; // Store for undo
                
                if (isSetTotal) {
                    dayLog.water = Math.max(0, amount);
                } else {
                    dayLog.water = Math.max(0, currentWater + amount);
                    lastWaterLogAmount = amount; // Store the amount *added* or *subtracted*
                }
                
                saveData();
                updateDayView(viewDate); // This updates the main summary and fill
                
                // Don't show undo for setting total, only for incremental changes
                if (!isSetTotal) {
                    // This is slightly different from user request, but more robust
                    // Let's stick to the "undo last log amount"
                    // We'll handle the undo logic in the gesture handler where `lastWaterLogAmount` is set
                }
            };

            // REMOVED: Water modal button listeners
            // ui.waterModalAddDefaultBtn.addEventListener('click', () => { ... });
            // ... all other modal listeners ...

            // --- NEW: Water Button Gesture Handling ---
            let waterPointerStart = { x: 0, y: 0 };
            let waterPointerDelta = { x: 0, y: 0 };
            let isWaterSwiping = false;

            function onWaterPointerDown(e) {
                const coords = getPointerCoordinates(e);
                waterPointerStart.x = coords.x;
                waterPointerStart.y = coords.y;
                waterPointerDelta = { x: 0, y: 0 };
                isWaterSwiping = false;

                document.addEventListener('mousemove', onWaterPointerMove);
                document.addEventListener('mouseup', onWaterPointerUp);
                document.addEventListener('touchmove', onWaterPointerMove, { passive: false });
                document.addEventListener('touchend', onWaterPointerUp);
            }

            function onWaterPointerMove(e) {
                const coords = getPointerCoordinates(e);
                waterPointerDelta.x = coords.x - waterPointerStart.x;
                waterPointerDelta.y = coords.y - waterPointerStart.y;

                if (!isWaterSwiping && (Math.abs(waterPointerDelta.x) > 10 || Math.abs(waterPointerDelta.y) > 10)) {
                    isWaterSwiping = true;
                }

                if (isWaterSwiping) {
                    // Prioritize vertical scroll prevention if swiping vertically
                    if (Math.abs(waterPointerDelta.y) > Math.abs(waterPointerDelta.x)) {
                         if (e.cancelable) e.preventDefault();
                    }
                }
            }

            function onWaterPointerUp(e) {
                document.removeEventListener('mousemove', onWaterPointerMove);
                document.removeEventListener('mouseup', onWaterPointerUp);
                document.removeEventListener('touchmove', onWaterPointerMove);
                document.removeEventListener('touchend', onWaterPointerUp);

                const totalDistance = Math.sqrt(waterPointerDelta.x**2 + waterPointerDelta.y**2);
                const dayLog = getDayLog(viewDate);

                if (!isWaterSwiping && totalDistance < 10) {
                    // --- TAP ---
                    const defaultSize = userProfile.waterServingSize || 250;
                    updateWater(defaultSize);
                } else if (isWaterSwiping) {
                    if (Math.abs(waterPointerDelta.y) > Math.abs(waterPointerDelta.x)) {
                        // --- VERTICAL SWIPE ---
                        if (waterPointerDelta.y < -20) { // Swipe Up
                            updateWater(50);
                        } else if (waterPointerDelta.y > 20) { // Swipe Down
                            updateWater(-50);
                        }
                    } else {
                        // --- HORIZONTAL SWIPE ---
                        if (waterPointerDelta.x < -20) { // Swipe Left: Undo last log
                            if (lastWaterLogAmount !== 0) {
                                const originalWater = dayLog.water;
                                const amountToUndo = lastWaterLogAmount;
                                dayLog.water = Math.max(0, originalWater - amountToUndo);
                                lastWaterLogAmount = 0; // Clear undo
                                saveData();
                                updateDayView(viewDate);
                                // Show the undo toast
                                showUndo('water', { originalWater: originalWater, newWater: dayLog.water });
                            }
                        } else if (waterPointerDelta.x > 20) { // Swipe Right: Edit Goal
                            showPromptModal("Set Water Goal", "Enter your new daily water goal (ml):", goals.water, (newGoalStr) => {
                                if (newGoalStr === null) return;
                                const newGoal = parseInt(newGoalStr);
                                if (!isNaN(newGoal) && newGoal > 0) {
                                    goals.water = newGoal;
                                    saveData();
                                    updateDayView(viewDate); // This will re-render fill %
                                } else {
                                    showCustomAlert("Invalid Goal", "Please enter a positive number for your goal.");
                                }
                            });
                        }
                    }
                }
                
                // Reset state
                isWaterSwiping = false;
                waterPointerDelta = { x: 0, y: 0 };
            }

            ui.addWaterBtn.addEventListener('mousedown', onWaterPointerDown);
            ui.addWaterBtn.addEventListener('touchstart', onWaterPointerDown, { passive: true });
            // --- END Water Button Gesture Handling ---

            // --- Combined Scanner Button Logic ---
            ui.scanCombinedBtn.addEventListener('click', () => {
                // Open the single AI scanner modal
                ui.scannerResultsContainer.innerHTML = '';
                ui.foodScannerStatus.textContent = '';
                ui.liveCameraContainer.classList.add('hidden');
                ui.foodScannerInitialOptions.classList.remove('hidden');
                ui.foodScannerCarouselWrapper.classList.add('hidden');
                showModal(ui.foodScannerModal); // ui.foodScannerModal now points to 'ai-scanner-modal'
            });
            // REMOVED Chooser modal listeners
            // ui.chooserScanBarcodeBtn.addEventListener('click', () => { ... });
            // ui.chooserScanFoodBtn.addEventListener('click', () => { ... });
            // ui.chooserScanCancelBtn.addEventListener('click', () => { ... });

            // --- AI Macro Swap Button ---
            ui.aiMacroSwapBtn.addEventListener('click', async () => {
                const btn = ui.aiMacroSwapBtn;
                const btnText = btn.querySelector('.btn-text');
                const loader = btn.querySelector('.loader');

                const foodName = capitalizeWords(ui.foodNameInput.value.trim());
                if (!foodName) {
                    showCustomAlert("No Food Entered", "Please enter a food name in the form first.");
                    return;
                }

                btn.disabled = true;
                btnText.style.display = 'none';
                loader.classList.remove('hidden');
                
                ui.aiSwapFoodName.textContent = foodName;
                showModal(ui.aiMacroSwapModal);
                ui.aiMacroSwapOutput.innerHTML = '<div class="loader mx-auto"></div>';

                try {
                    const swaps = await getAiMacroSwaps(foodName);
                    
                    if (swaps && swaps.length > 0) {
                        ui.aiMacroSwapOutput.innerHTML = swaps.map(swap => `
                            <button type="button" class="btn btn-secondary w-full !justify-between !text-left swap-suggestion-btn" data-food-name="${swap.name}">
                                <div class="flex flex-col">
                                    <span class="font-semibold text-white">${swap.name}</span>
                                    <span class="text-xs text-gray-400 font-normal">${swap.reason}</span>
                                </div>
                                <i data-lucide="chevron-right" class="w-5 h-5 text-gray-400"></i>
                            </button>
                        `).join('');
                        lucide.createIcons();
                    } else {
                        ui.aiMacroSwapOutput.innerHTML = `<p class="text-gray-400 text-center">No swap suggestions found for "${foodName}".</p>`;
                    }

                } catch (error) {
                    console.error("AI Macro Swap Error:", error);
                    ui.aiMacroSwapOutput.innerHTML = `<p class="text-red-400">${error.message}</p>`;
                } finally {
                    btn.disabled = false;
                    btnText.style.display = 'inline-block';
                    loader.classList.add('hidden');
                }
            });

            async function getAiMacroSwaps(foodName) {
                const systemPrompt = `User is considering eating '${foodName}'. Their goal is ${userProfile.goal}. Suggest 3-5 healthier alternatives that fit a similar craving (e.g., salty, sweet, crunchy). For each, provide 'name' and 'reason' (why it's better, e.g., "Lower in fat", "Higher in protein"). Respond ONLY with a valid JSON array of objects: [{name: "Food 1", reason: "Lower in fat"}, {name: "Food 2", reason: "Higher in protein"}]`;
                
                const userQuery = `Suggest swaps for ${foodName}`;

                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                const payload = {
                     contents: [{ parts: [{ text: userQuery }] }],
                     systemInstruction: { parts: [{ text: systemPrompt }] },
                     generationConfig: { responseMimeType: "application/json" }
                };

                try {
                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");
                    return JSON.parse(result.candidates[0].content.parts[0].text);
                } catch (error) {
                    console.error("getAiMacroSwaps Error:", error);
                    throw error;
                }
            }

            ui.closeAiMacroSwapModalBtn.addEventListener('click', () => hideModal(ui.aiMacroSwapModal));
            
            // Event delegation for swap suggestions
            ui.aiMacroSwapOutput.addEventListener('click', (e) => {
                const swapBtn = e.target.closest('.swap-suggestion-btn');
                if (swapBtn) {
                    const foodName = swapBtn.dataset.foodName;
                    if (foodName) {
                        // 1. Update form
                        ui.foodNameInput.value = foodName;
                        // 2. Clear all macro inputs
                        const macroInputs = ui.logMealForm.querySelectorAll('.macro-input');
                        macroInputs.forEach(input => input.value = '');
                        ui.foodGramsInput.value = '';
                        ui.foodBrandInput.value = '';
                        ui.foodServingsInput.value = 1;

                        // 3. Hide modal
                        hideModal(ui.aiMacroSwapModal);

                        // 4. Scroll to form and trigger AI lookup
                        ui.logMealForm.scrollIntoView({ behavior: 'smooth' });
                        ui.addFoodBtn.click();
                    }
                }
            });


            // --- Edit/Delete Log Item Handlers ---
             const handleEditLogItem = (index) => {
                 const item = getCurrentDayLogEntries()[index];
                 if(!item) return;

                editingFoodLogIndex = index;
                ui.foodNameInput.value = item.name;
                ui.foodServingsInput.value = item.servings;

                // Calculate single serving macros and grams
                const singleServingGrams = (item.grams / item.servings) || 0;
                ui.foodGramsInput.value = singleServingGrams > 0 ? singleServingGrams.toFixed(1) : '';

                document.getElementById('food-calories-input').value = ((item.calories / item.servings) || 0).toFixed(2);
                document.getElementById('food-protein-input').value = ((item.protein / item.servings) || 0).toFixed(2);
                document.getElementById('food-carbs-input').value = ((item.carbs / item.servings) || 0).toFixed(2);
                document.getElementById('food-fat-input').value = ((item.fat / item.servings) || 0).toFixed(2);
                document.getElementById('food-sugar-input').value = ((item.sugar / item.servings) || 0).toFixed(2);
                document.getElementById('food-sodium-input').value = ((item.sodium / item.servings) || 0).toFixed(2);
                document.getElementById('food-potassium-input').value = ((item.potassium / item.servings) || 0).toFixed(2);

                // Open the details section if it exists
                const detailsElement = ui.logMealForm.querySelector('details');
                if (detailsElement) detailsElement.open = true;

                ui.logMealForm.scrollIntoView({ behavior: 'smooth' });
             };

            const handleDeleteLogItem = (index) => {
                showConfirmModal('Delete Log Entry?', 'Are you sure?', () => {
                    let dayLog = getDayLog(viewDate);
                    if (dayLog && dayLog.entries && dayLog.entries[index]) {
                        const itemToDelete = dayLog.entries.splice(index, 1)[0];
                        saveData();
                        fullRender();
                        showUndo('delete', { index, item: itemToDelete });
                    }
                });
            };

            // AI Daily Report
            ui.aiDailyReportBtn.addEventListener('click', getDailyLogAIReport);
            ui.closeAiReportModalBtn.addEventListener('click', () => hideModal(ui.aiReportModal));
            ui.aiReportModalOkBtn.addEventListener('click', () => hideModal(ui.aiReportModal));

            // Clear AI base macros cache on input change
            ['food-name-input', 'food-brand-input'].forEach(id => document.getElementById(id).addEventListener('input', () => { aiBaseMacros = null; }));

            // AI Meal Suggester
            ui.aiMealSuggesterBtn.addEventListener('click', () => {
                ui.aiSuggestionsOutput.innerHTML = '';
                ui.aiIngredientsInput.value = '';
                showModal(ui.aiSuggesterModal);
            });
            ui.closeAiSuggesterModalBtn.addEventListener('click', () => hideModal(ui.aiSuggesterModal));
            ui.aiSuggestionBtn.addEventListener('click', async () => {
                const btn = ui.aiSuggestionBtn, btnText = btn.querySelector('.btn-text'), loader = btn.querySelector('.loader');
                const ingredients = ui.aiIngredientsInput.value.trim();
                if (!ingredients) { ui.aiSuggestionsOutput.innerHTML = `<p class="text-yellow-400">Please enter some ingredients.</p>`; return; }
                btn.disabled = true; btnText.style.display = 'none'; loader.classList.remove('hidden'); ui.aiSuggestionsOutput.innerHTML = '';
                const currentDayLogEntries = getCurrentDayLogEntries();
                const remainingCalories = Math.max(0, goals.calories - currentDayLogEntries.reduce((sum, item) => sum + item.calories, 0));
                const prompt = `I have: ${ingredients}. I have about ${remainingCalories} calories left. My goal is ${userProfile.goal}. Suggest one simple, healthy meal. Provide the name, prep/cook time, and simple step-by-step instructions. Format with Markdown.`;
                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                const payload = { contents: [{ parts: [{ text: prompt }] }] };
                try {
                    const result = await fetchWithBackoff(apiUrl, payload); // Use fetchWithBackoff
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");
                    let text = result.candidates[0].content.parts[0].text;
                    text = text.replace(/\*\*(.*?)\*\*/g, '<h3 class="text-lg font-semibold mt-4 mb-2">$1</h3>').replace(/\*/g, '').replace(/(\d+\.)/g, '<br>$1');
                    ui.aiSuggestionsOutput.innerHTML = `<div class="bg-black/30 p-4 rounded-lg text-sm">${text}</div>`;
                } catch (error) {
                    console.error("AI Suggestion Error:", error);
                    ui.aiSuggestionsOutput.innerHTML = `<p class="text-red-400">Could not get a suggestion. ${error.message}</p>`;
                } finally {
                    btn.disabled = false; btnText.style.display = 'inline'; loader.classList.add('hidden');
                }
            });

            // Convert uploaded file to generative part
            function fileToGenerativePart(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onloadend = () => { const base64Data = reader.result.split(',')[1]; resolve({ inlineData: { mimeType: file.type, data: base64Data } }); }; reader.onerror = (err) => reject(err); reader.readAsDataURL(file); }); }

            // --- UNIFIED AI SCANNER ---
            
            // New function to classify image
            async function getAiImageClassification(imagePart) {
                const prompt = "Is this image primarily a barcode or a picture of food? Respond with ONLY 'barcode' or 'food'.";
                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                const payload = { contents: [{ parts: [{ text: prompt }, imagePart] }] };
                try {
                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid classification response.");
                    return result.candidates[0].content.parts[0].text.trim().toLowerCase();
                } catch (error) {
                    console.error("AI Classification Error:", error);
                    return 'error'; // Return 'error' on failure
                }
            }

            // New function to process barcode scan results and populate element
            async function processBarcodeScan(decodedText, file, resultElement) {
                const imageUrl = URL.createObjectURL(file);
                resultElement.querySelector('img').src = imageUrl;
                resultElement.querySelector('img').onerror = function() { this.onerror=null; this.src='https://placehold.co/300x150/191919/FFFFFF?text=No+Image'; };
                
                try {
                    const response = await fetch(`https://world.openfoodfacts.org/api/v2/product/${decodedText}?fields=product_name,brands,nutriments,serving_size,quantity`);
                    if(!response.ok) throw new Error('Product not found in Open Food Facts database.');
                    const data = await response.json();
                    if(data.status === 0 || !data.product) throw new Error(data.status_verbose || 'Product not found.');
                    
                    const product = data.product, nutriments = product.nutriments;
                    const per100g = {
                        calories: nutriments['energy-kcal_100g'] || 0, protein: nutriments.proteins_100g || 0, carbs: nutriments.carbohydrates_100g || 0, fat: nutriments.fat_100g || 0, sugar: nutriments.sugars_100g || 0, sodium: (nutriments.sodium_100g || 0) * 1000, potassium: (nutriments.potassium_100g || 0) * 1000,
                    };

                    let defaultGrams = 100;
                    if (product.serving_size) {
                        const servingMatch = String(product.serving_size).match(/(\d+(\.\d+)?)/);
                        if (servingMatch) { defaultGrams = parseFloat(servingMatch[0]); }
                    } else if (product.quantity) {
                         const quantityMatch = String(product.quantity).match(/(\d+(\.\d+)?)/);
                         if (quantityMatch) { defaultGrams = parseFloat(quantityMatch[0]); }
                    }

                    const productName = capitalizeWords(product.product_name) || 'Scanned Item';

                    const detailsContainer = document.createElement('div');
                    detailsContainer.innerHTML = `
                        <p class="font-bold whitespace-normal">${productName}</p>
                        <p class="text-xs text-gray-400 mb-3">Barcode: ${decodedText}</p>
                        <div class="flex items-center gap-2">
                            <input type="number" value="${defaultGrams.toFixed(0)}" class="form-input !py-1.5 text-center barcode-grams-input" min="0">
                            <span class="text-gray-400">grams</span>
                        </div>
                    `;
                    
                    const logButton = document.createElement('button');
                    logButton.className = 'btn btn-primary !p-2 mt-3 w-full data-log-button';
                    logButton.textContent = 'Log this';
                    logButton.isLogged = false;
                    logButton.logId = null;

                    const gramsInput = detailsContainer.querySelector('.barcode-grams-input');

                    logButton.onclick = () => {
                        const grams = parseFloat(gramsInput.value);
                        if (isNaN(grams) || grams <= 0) {
                            gramsInput.classList.add('!border-red-500');
                            setTimeout(() => gramsInput.classList.remove('!border-red-500'), 1500);
                            return;
                        }

                        if (logButton.isLogged) {
                            // UNLOG
                            const logIndex = getDayLog(viewDate).entries.findIndex(entry => entry.logId === logButton.logId);
                            if (logIndex > -1) {
                                getDayLog(viewDate).entries.splice(logIndex, 1);
                                saveData();
                                updateDayView(viewDate);
                            }
                            logButton.textContent = 'Log this';
                            logButton.classList.remove('btn-secondary');
                            logButton.classList.add('btn-primary');
                            logButton.isLogged = false;
                            logButton.logId = null;
                            gramsInput.disabled = false;
                        } else {
                            // LOG
                            const logId = Date.now();
                            const ratio = grams / 100.0;
                            const foodItem = {
                                logId: logId, name: productName, brand: product.brands || '', servings: 1, grams: grams,
                                calories: (per100g.calories * ratio) || 0, protein: (per100g.protein * ratio) || 0,
                                carbs: (per100g.carbs * ratio) || 0, fat: (per100g.fat * ratio) || 0,
                                sugar: (per100g.sugar * ratio) || 0, sodium: (per100g.sodium * ratio) || 0,
                                potassium: (per100g.potassium * ratio) || 0,
                            };
                            const dayLog = getDayLog(viewDate);
                            dayLog.entries.unshift(foodItem);
                            saveData();
                            updateDayView(viewDate);

                            logButton.textContent = 'Logged! (Tap to undo)';
                            logButton.classList.remove('btn-primary');
                            logButton.classList.add('btn-secondary');
                            logButton.isLogged = true;
                            logButton.logId = logId;
                            gramsInput.disabled = true;
                        }
                    };

                    resultElement.querySelector('.loader')?.remove();
                    resultElement.appendChild(detailsContainer);
                    resultElement.appendChild(logButton);

                } catch (error) {
                    resultElement.querySelector('.loader')?.remove();
                    resultElement.innerHTML += `<p class="text-red-400 text-xs">Error finding barcode data. ${error.message}</p>`;
                }
            }


            // Renamed function
            async function startAiCamera() {
                ui.foodScannerInitialOptions.classList.add('hidden');
                ui.liveCameraContainer.classList.remove('hidden');
                ui.foodScannerStatus.textContent = 'Starting camera...';
                try {
                    foodCameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
                    ui.foodCameraVideo.srcObject = foodCameraStream;
                    ui.foodScannerStatus.textContent = 'Camera active. Point and capture.';
                } catch (err) {
                    console.error("Camera access error:", err);
                    ui.foodScannerStatus.textContent = 'Could not access camera.';
                    stopAiCamera();
                }
            }

            // Renamed function
            function stopAiCamera() {
                if (foodCameraStream) {
                    foodCameraStream.getTracks().forEach(track => track.stop());
                }
                foodCameraStream = null;
                ui.liveCameraContainer.classList.add('hidden');
                ui.foodScannerInitialOptions.classList.remove('hidden');
                ui.foodScannerStatus.textContent = '';
            }

            // Renamed function
            function captureAiPhoto() {
                const video = ui.foodCameraVideo;
                const canvas = ui.foodCameraCanvas;
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const context = canvas.getContext('2d');
                context.drawImage(video, 0, 0, canvas.width, canvas.height);

                canvas.toBlob(blob => {
                    if (blob) {
                        const file = new File([blob], `capture-${Date.now()}.jpg`, { type: 'image/jpeg' });
                        handleAiScanFiles([file]);
                    }
                }, 'image/jpeg', 0.9);
            }

            // Event listener for the renamed modal
            ui.closeFoodScannerModalBtn.addEventListener('click', () => {
                stopAiCamera(); // Use renamed function
                hideModal(ui.foodScannerModal);
            });

            // Event listeners for renamed buttons
            ui.startFoodCameraBtn.addEventListener('click', startAiCamera);
            ui.stopFoodCameraBtn.addEventListener('click', stopAiCamera);
            ui.captureFoodPhotoBtn.addEventListener('click', captureAiPhoto);


            // Renamed function, takes imagePart and resultElement
            async function processFoodImageAI(imagePart, resultElement) {
                try {
                    let prompt = `Identify the food in this image. Respond ONLY with a valid JSON object with these fields: "name", "brand", "servings" (estimated number of standard servings shown), "totalGrams" (estimated total grams for all servings shown), "calories", "protein", "carbs", "fat", "sugar", "sodium", "potassium". The nutritional values (calories, protein, etc.) should be for the TOTAL amount of food pictured.`;

                    const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                    const payload = { contents: [{ parts: [{ text: prompt }, imagePart] }], generationConfig: { responseMimeType: "application/json" } };

                    const result = await fetchWithBackoff(apiUrl, payload); // Use fetchWithBackoff
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");

                    const data = JSON.parse(result.candidates[0].content.parts[0].text);
                    resultElement.querySelector('.loader')?.remove();

                    const detailsDiv = document.createElement('div');
                    detailsDiv.className = 'text-xs text-gray-400 whitespace-normal';

                    detailsDiv.innerHTML = `
                        <p class="font-bold text-sm text-white mb-1">${capitalizeWords(data.name) || 'Unknown Food'} (${(data.servings || 1).toFixed(1)} serv.)</p>
                        <p>${data.totalGrams?.toFixed(0) || '?'}g | ${data.calories?.toFixed(0) || '?'} kcal</p>
                        <p>${data.protein?.toFixed(1) || '?'}p | ${data.carbs?.toFixed(1) || '?'}c | ${data.fat?.toFixed(1) || '?'}f</p>
                    `;

                    const logButton = document.createElement('button');
                    logButton.className = 'btn btn-primary !p-2 mt-3 w-full';
                    logButton.innerHTML = 'Log this';
                    logButton.isLogged = false;
                    logButton.logId = null;

                    logButton.onclick = () => {
                        if (logButton.isLogged) {
                            // UNLOG
                            const logIndex = getDayLog(viewDate).entries.findIndex(entry => entry.logId === logButton.logId);
                            if (logIndex > -1) {
                                getDayLog(viewDate).entries.splice(logIndex, 1);
                                saveData();
                                updateDayView(viewDate);
                            }
                            logButton.textContent = 'Log this';
                            logButton.classList.remove('btn-secondary');
                            logButton.classList.add('btn-primary');
                            logButton.isLogged = false;
                            logButton.logId = null;
                        } else {
                            // LOG
                            const logId = Date.now();
                            const foodItem = {
                                logId: logId, name: capitalizeWords(data.name) || 'Scanned Food', brand: data.brand || '',
                                servings: data.servings || 1, grams: data.totalGrams || 0,
                                calories: data.calories || 0, protein: data.protein || 0, carbs: data.carbs || 0, fat: data.fat || 0,
                                sugar: data.sugar || 0, sodium: data.sodium || 0, potassium: data.potassium || 0,
                            };
                            const dayLog = getDayLog(viewDate);
                            dayLog.entries.unshift(foodItem); // Add to beginning
                            saveData();
                            updateDayView(viewDate);

                            logButton.textContent = 'Logged! (Tap to undo)';
                            logButton.classList.remove('btn-primary');
                            logButton.classList.add('btn-secondary');
                            logButton.isLogged = true;
                            logButton.logId = logId;
                        }
                    };
                    resultElement.appendChild(detailsDiv);
                    resultElement.appendChild(logButton);

                } catch (error) {
                    console.error("AI Image Scan Error:", error);
                    resultElement.querySelector('.loader')?.remove();
                     resultElement.innerHTML += `<p class="text-red-400 text-xs">Error analyzing. ${error.message}</p>`;
                }
            }

            // New classifier function
            async function classifyAndProcessImage(file, resultElement) {
                try {
                    const imagePart = await fileToGenerativePart(file);
                    const classification = await getAiImageClassification(imagePart);

                    if (classification.includes('barcode')) {
                        ui.foodScannerStatus.textContent = 'Barcode detected, scanning...';
                        try {
                            // Try local barcode scan first
                            const qrCodeInstance = new Html5Qrcode("barcode-reader-hidden-helper");
                            const decodedText = await qrCodeInstance.scanFile(file, false);
                            qrCodeInstance.clear();
                            await processBarcodeScan(decodedText, file, resultElement);
                        } catch (err) {
                            // Local scan failed, fallback to food AI
                            ui.foodScannerStatus.textContent = 'Barcode scan failed, trying food analysis...';
                            await processFoodImageAI(imagePart, resultElement);
                        }
                    } else if (classification.includes('food')) {
                        ui.foodScannerStatus.textContent = 'Food detected, analyzing...';
                        await processFoodImageAI(imagePart, resultElement);
                    } else {
                        throw new Error("Could not classify image.");
                    }
                } catch (error) {
                    resultElement.querySelector('.loader')?.remove();
                    resultElement.innerHTML += `<p class="text-red-400 text-xs">Scan failed. ${error.message}</p>`;
                }
            }

            // Renamed function
            function handleAiScanFiles(files) {
                if (!files || files.length === 0) return;
                 ui.foodScannerCarouselWrapper.classList.remove('hidden'); // Use wrapper ID

                for(const file of files) {
                    const resultElement = document.createElement('div');
                    resultElement.className = 'scroll-item p-4 bg-input-bg rounded-lg text-center';
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        resultElement.innerHTML = `
                            <img src="${e.target.result}" class="w-full h-24 object-cover rounded-md mb-2">
                            <div class="loader mx-auto"></div>
                        `;
                    };
                    reader.readAsDataURL(file);
                    ui.scannerResultsContainer.appendChild(resultElement); // Use renamed container
                    classifyAndProcessImage(file, resultElement); // Call new classifier
                }
                setupCarousel('ai-scanner-results-container', 'ai-scanner-prev', 'ai-scanner-next');
            }

            ui.uploadPhotoInput.addEventListener('change', (e) => handleAiScanFiles(e.target.files)); // Use renamed handler

            // --- Create Recipe Button (Removed) ---
            // ui.createRecipeBtn.addEventListener('click', () => { ... });

            // --- Log from Saved Items ---
            ui.savedItemsListDiv.addEventListener('click', (e) => {
                 const logBtn = e.target.closest('.log-item-btn');
                 if(!logBtn) return;
                const container = logBtn.closest('.swipe-item');
                const type = container.dataset.type;
                const index = parseInt(container.dataset.index);

                if (type === 'food') {
                    const food = favoriteFoods[index]; if (!food) return;
                    showPromptModal(`Log Food: ${food.name}`, `How many grams of ${food.name}?`, "100", (weightStr) => {
                        if (weightStr === null) return; const grams = parseFloat(weightStr); if (isNaN(grams) || grams <= 0) { showCustomAlert('Invalid Input', 'Please enter a valid number for grams.'); return; }
                        const ratio = grams / 100; const foodItem = { name: food.name, servings: 1, grams, calories: (food.calories || 0) * ratio, protein: (food.protein || 0) * ratio, carbs: (food.carbs || 0) * ratio, fat: (food.fat || 0) * ratio, sugar: (food.sugar || 0) * ratio, sodium: (food.sodium || 0) * ratio, potassium: (food.potassium || 0) * ratio };
                        const dayLog = getDayLog(viewDate);
                        dayLog.entries.unshift(foodItem);
                        saveData(); updateDayView(viewDate); showCustomAlert('Success', `${grams}g of ${food.name} added to the log.`);
                    });
                } else if (type === 'recipe') {
                    // Recipe logging logic removed as recipe creation is removed
                     showCustomAlert("Error", "Recipe logging is currently unavailable.");
                }
            });

            // --- Edit Favorite Food Form ---
            ui.editFavoriteForm.addEventListener('submit', (e) => {
                e.preventDefault(); const favIndex = favoriteFoods.findIndex(f => f.name === editingFavoriteFoodName); if (favIndex === -1) return;
                const newName = capitalizeWords(document.getElementById('edit-fav-food-name').value.trim());
                if (newName.toLowerCase() !== editingFavoriteFoodName.toLowerCase() && (favoriteFoods.some(f => f.name.toLowerCase() === newName.toLowerCase()) || savedRecipes.some(r => r.name.toLowerCase() === newName.toLowerCase()))) { showCustomAlert('Name Exists', 'A favorite food or recipe with this name already exists.'); return; }
                favoriteFoods[favIndex].name = newName; favoriteFoods[favIndex].calories = parseFloat(document.getElementById('edit-fav-food-calories').value); favoriteFoods[favIndex].protein = parseFloat(document.getElementById('edit-fav-food-protein').value); favoriteFoods[favIndex].carbs = parseFloat(document.getElementById('edit-fav-food-carbs').value); favoriteFoods[favIndex].fat = parseFloat(document.getElementById('edit-fav-food-fat').value);
                // Also save optional fields if they exist in the modal
                 favoriteFoods[favIndex].sugar = parseFloat(document.getElementById('edit-fav-food-sugar')?.value) || 0;
                 favoriteFoods[favIndex].sodium = parseFloat(document.getElementById('edit-fav-food-sodium')?.value) || 0;
                 favoriteFoods[favIndex].potassium = parseFloat(document.getElementById('edit-fav-food-potassium')?.value) || 0;
                saveData(); fullRender(); hideModal(ui.editFavoriteModal);
            });


            // OTHER MODAL LISTENERS
            ui.closeEditFavoriteModalBtn.addEventListener('click', () => hideModal(ui.editFavoriteModal));
            // ui.closeCompoundFoodModalBtn.addEventListener('click', () => hideModal(ui.compoundFoodModal)); // Removed
            ui.alertModalOkBtn.addEventListener('click', () => hideModal(ui.alertModal));
            ui.confirmModalCancelBtn.addEventListener('click', () => hideModal(ui.confirmModal));
            ui.confirmModalConfirmBtn.addEventListener('click', () => { if (confirmCallback) confirmCallback(); hideModal(ui.confirmModal); });
            ui.promptModalCancelBtn.addEventListener('click', () => { if (promptCallback) promptCallback(null); hideModal(ui.promptModal); });
            ui.promptModalOkBtn.addEventListener('click', () => { if(promptCallback) promptCallback(ui.promptModalInput.value); hideModal(ui.promptModal); });

            // REMOVED BARCODE LISTENERS
            // const startBarcodeScanner = () => { ... };
            // const stopBarcodeScanner = () => { ... };
            // const initiateLiveScanner = () => { ... };
            // async function onScanSuccess(decodedText, decodedResult, imageUrl = null) { ... }
            // function onScanFailure(error) { ... }
            // ui.closeBarcodeScannerModalBtn.addEventListener('click', stopBarcodeScanner);
            // document.getElementById('start-camera-scan-btn')?.addEventListener('click', initiateLiveScanner);
            // document.getElementById('barcode-upload-input')?.addEventListener('change', async (e) => { ... });
            // ui.manualBarcodeSubmit.addEventListener('click', () => { ... });
            // ui.manualBarcodeInput.addEventListener('keydown', (e) => { ... });


            // --- AI Nutritionist Chat ---
            ui.openNutritionistChatBtn.addEventListener('click', () => {
                renderChatHistory();
                showModal(ui.aiNutritionistModal);
            });
            ui.closeAiNutritionistModalBtn.addEventListener('click', () => hideModal(ui.aiNutritionistModal));
            ui.aiChatSendBtn.addEventListener('click', handleAiChatSend);
            ui.aiChatInput.addEventListener('keydown', (e) => { if(e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleAiChatSend(); } });

            async function handleAiChatSend() {
                const userInput = ui.aiChatInput.value.trim();
                if(!userInput) return;

                chatHistory.push({ role: "user", parts: [{ text: userInput }] });
                addMessageToChat(userInput, 'user');
                ui.aiChatInput.value = '';
                ui.aiChatSendBtn.disabled = true;
                addMessageToChat('<div class="loader"></div>', 'model', true);

                try {
                    const sevenDaysAgo = new Date();
                    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
                    const recentLogs = Object.entries(allDailyLogs).filter(([date]) => new Date(date) >= sevenDaysAgo);
                    const context = `
                        User Profile: ${JSON.stringify(userProfile)}
                        Nutrition Goals: ${JSON.stringify(goals)}
                        Last 7 Days Food Log: ${JSON.stringify(recentLogs)}
                    `;
                    const systemPrompt = `You are FitTrack AI, a helpful and knowledgeable nutritionist. Analyze the user's provided data to give specific, actionable advice based on their question. Be encouraging and provide clear, concise answers. Here is the user's data context: ${context}`;

                    const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                    const payload = {
                        contents: chatHistory,
                        systemInstruction: { parts: [{ text: systemPrompt }] }
                    };

                    const result = await fetchWithBackoff(apiUrl, payload); // Use fetchWithBackoff
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");
                    const aiResponse = result.candidates[0].content.parts[0].text;

                    chatHistory.push({ role: "model", parts: [{ text: aiResponse }] });
                    updateLastMessage(aiResponse.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'));

                } catch(error) {
                    console.error("AI Chat Error:", error);
                    updateLastMessage(`Sorry, I am having trouble connecting right now. ${error.message}`);
                    // Remove the last user message if AI fails, so they can try again
                    chatHistory.pop();
                } finally {
                    ui.aiChatSendBtn.disabled = false;
                    saveData();
                }
            }


            function renderChatHistory() {
                if(chatHistory.length === 0) {
                     ui.aiChatHistory.innerHTML = `<div class="text-center text-secondary-text p-4"><i data-lucide="bot" class="w-10 h-10 mx-auto mb-2"></i><p>Hello! I'm your AI Nutritionist. Ask me anything about your diet, food logs, or general nutrition.</p></div>`;
                     lucide.createIcons();
                } else {
                    ui.aiChatHistory.innerHTML = '';
                    chatHistory.forEach(msg => {
                        addMessageToChat(msg.parts[0].text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'), msg.role);
                    });
                }
            }


            function addMessageToChat(message, sender, isLoading = false) {
                 if (chatHistory.length === 1 && sender === 'user') { ui.aiChatHistory.innerHTML = ''; }
                const messageDiv = document.createElement('div');
                messageDiv.className = `p-3 rounded-lg max-w-[85%] ${sender === 'user' ? 'bg-blue-600 self-end' : 'bg-input-bg self-start'}`;
                if(isLoading) messageDiv.id = 'ai-loading-message';
                messageDiv.innerHTML = message;
                ui.aiChatHistory.appendChild(messageDiv);
                ui.aiChatHistory.scrollTop = ui.aiChatHistory.scrollHeight;
            }
             function updateLastMessage(newMessage) {
                const loadingMessage = document.getElementById('ai-loading-message');
                if (loadingMessage) {
                    loadingMessage.innerHTML = newMessage;
                    loadingMessage.removeAttribute('id');
                }
            }

            // --- SWIPE GESTURES ---
            function handleItemDelete(element) {
                const type = element.dataset.type;
                const index = parseInt(element.dataset.index);
                const name = element.dataset.name;

                if (type === 'log') {
                    handleDeleteLogItem(index);
                } else if (type === 'food' || type === 'recipe') {
                    showConfirmModal(`Delete ${type}?`, `Are you sure you want to delete "${name}"?`, () => {
                        if (type === 'food') {
                            favoriteFoods.splice(index, 1);
                        } else if (type === 'recipe') {
                            // Recipe deletion logic removed
                            // savedRecipes.splice(index, 1);
                            // const favIndex = favoriteFoods.findIndex(f => f.name.toLowerCase() === name.toLowerCase());
                            // if (favIndex > -1) favoriteFoods.splice(favIndex, 1);
                             showCustomAlert("Action Unavailable", "Recipe deletion is currently disabled."); // Inform user
                        }
                        saveData();
                        fullRender();
                    });
                }
            }

            function handleItemEdit(element) {
                const type = element.dataset.type;
                const index = parseInt(element.dataset.index);

                if (type === 'log') {
                    handleEditLogItem(index);
                } else if (type === 'food') {
                    const food = favoriteFoods[index];
                    if (!food) return;
                    editingFavoriteFoodName = food.name;
                    document.getElementById('edit-fav-food-name').value = food.name;
                    document.getElementById('edit-fav-food-calories').value = (food.calories || 0).toFixed(2);
                    document.getElementById('edit-fav-food-protein').value = (food.protein || 0).toFixed(2);
                    document.getElementById('edit-fav-food-carbs').value = (food.carbs || 0).toFixed(2);
                    document.getElementById('edit-fav-food-fat').value = (food.fat || 0).toFixed(2);
                     // Add optional fields if they exist in the modal/data
                    // document.getElementById('edit-fav-food-sugar').value = (food.sugar || 0).toFixed(2);
                document.getElementById('edit-fav-food-sugar').value = (food.sugar || 0).toFixed(2);
                document.getElementById('edit-fav-food-sodium').value = (food.sodium || 0).toFixed(0);
                document.getElementById('edit-fav-food-potassium').value = (food.potassium || 0).toFixed(0);
                showModal(ui.editFavoriteModal);
                } else if (type === 'recipe') {
                     showCustomAlert("Coming Soon", "Recipe editing is currently under development.");
                    // Recipe editing logic removed
                    // const recipe = savedRecipes[index];
                    // if (!recipe) return;
                    // editingRecipeIndex = index;
                    // ui.compoundFoodModal.querySelector('h2').textContent = "Edit Recipe";
                    // ui.saveRecipeBtn.textContent = "Update Recipe";
                    // ui.recipeNameInput.value = recipe.name;
                    // ui.ingredientListContainer.innerHTML = '';
                    // recipe.ingredients.forEach((ing, i) => addIngredientRow(ing, i));
                    // if (recipe.ingredients.length === 0) addIngredientRow();
                    // updateRecipeTotals();
                    // showModal(ui.compoundFoodModal);
                    // setupCarousel('ingredient-list-container', 'recipe-prev-ingredient', 'recipe-next-ingredient');
                }
            }

            let pointerStart = { x: 0, y: 0 };
            let currentX = 0;
            let isSwiping = false;
            let swipedElement = null;
            let lastTap = 0;
            let pointerDelta = { x: 0, y: 0 };

            function getPointerCoordinates(e) {
                return e.touches ? { x: e.touches[0].clientX, y: e.touches[0].clientY } : { x: e.clientX, y: e.clientY };
            }

            function handlePointerDown(e) {
                const target = e.target.closest('.swipe-item');
                if (!target || e.target.closest('button, a, input, select, textarea')) return;

                const coords = getPointerCoordinates(e);
                pointerStart.x = coords.x;
                pointerStart.y = coords.y;
                pointerDelta = { x: 0, y: 0 };
                currentX = 0;
                swipedElement = target;
                swipedElement.querySelector('.swipe-content').classList.add('swiping');

                document.addEventListener('mousemove', handlePointerMove);
                document.addEventListener('mouseup', handlePointerUp);
                document.addEventListener('touchmove', handlePointerMove, { passive: false });
                document.addEventListener('touchend', handlePointerUp);
            }

            function handlePointerMove(e) {
                if (!swipedElement) return;

                const coords = getPointerCoordinates(e);
                const deltaX = coords.x - pointerStart.x;
                const deltaY = coords.y - pointerStart.y;
                pointerDelta = { x: deltaX, y: deltaY };

                if (!isSwiping && Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
                    isSwiping = true;
                }

                if (isSwiping) {
                    if (e.cancelable) e.preventDefault();
                    currentX = deltaX;
                    const content = swipedElement.querySelector('.swipe-content');
                    content.style.transform = `translateX(${currentX}px)`;

                    const rightAction = swipedElement.querySelector('.swipe-action-container.right');
                    const leftAction = swipedElement.querySelector('.swipe-action-container.left');

                    if (currentX < 0) { // Swiping left
                        if(rightAction) rightAction.style.opacity = Math.min(1, Math.abs(currentX) / 80).toString();
                        if(leftAction) leftAction.style.opacity = '0';
                    } else { // Swiping right
                        if(leftAction) leftAction.style.opacity = Math.min(1, currentX / 80).toString();
                        if(rightAction) rightAction.style.opacity = '0';
                    }
                }
            }

            function handlePointerUp(e) {
                document.removeEventListener('mousemove', handlePointerMove);
                document.removeEventListener('mouseup', handlePointerUp);
                document.removeEventListener('touchmove', handlePointerMove);
                document.removeEventListener('touchend', handlePointerUp);

                if (!swipedElement) return;

                const elementToClean = swipedElement;
                const content = elementToClean.querySelector('.swipe-content');

                const currentTime = new Date().getTime();
                const isDoubleTap = (currentTime - lastTap) < 300 && !isSwiping;
                lastTap = currentTime;

                const totalDistance = Math.sqrt(pointerDelta.x**2 + pointerDelta.y**2);

                if (isSwiping) {
                    const swipeThreshold = elementToClean.offsetWidth * 0.35;
                    content.classList.add('returning');
                    if (currentX < -swipeThreshold) { // Swiped left for Edit
                        handleItemEdit(elementToClean);
                        content.style.transform = 'translateX(0)';
                    } else if (currentX > swipeThreshold) { // Swiped right for Delete
                        handleItemDelete(elementToClean);
                        // Element might be removed, so don't reset transform immediately
                    } else {
                        content.style.transform = 'translateX(0)';
                    }
                } else if (totalDistance < 10) { // It's a tap
                    if (isDoubleTap) {
                        const itemName = elementToClean.dataset.name;
                        if (itemName) {
                            toggleFavorite(itemName);
                        }
                    }
                }

                isSwiping = false;
                swipedElement = null;
                currentX = 0;
                pointerDelta = { x: 0, y: 0 };

                // Only reset style if the element wasn't deleted
                if (elementToClean && document.body.contains(elementToClean)) {
                    setTimeout(() => {
                        if(content) {
                            content.classList.remove('swiping', 'returning');
                            content.style.transform = '';
                        }
                         const actions = elementToClean.querySelectorAll('.swipe-action-container');
                         if(actions) actions.forEach(el => el.style.opacity = '0');
                    }, 300);
                }
            }

            ui.dailyLogContentDiv.addEventListener('mousedown', handlePointerDown);
            ui.dailyLogContentDiv.addEventListener('touchstart', handlePointerDown, { passive: true });
            ui.savedItemsListDiv.addEventListener('mousedown', handlePointerDown);
            ui.savedItemsListDiv.addEventListener('touchstart', handlePointerDown, { passive: true });

            // --- DAY VIEW SWIPE GESTURES ---
            let daySwipeStart = { x: 0, y: 0 };
            let daySwipeCurrentX = 0;
            let isDaySwiping = false;
            let daySwipeElement = null;

            function handleDaySwipePointerDown(e) {
                const target = e.target.closest('#daily-summary-card');
                if (!target) return;

                const coords = getPointerCoordinates(e);
                daySwipeStart.x = coords.x;
                daySwipeStart.y = coords.y;
                daySwipeCurrentX = 0;
                daySwipeElement = target;

                document.addEventListener('mousemove', handleDaySwipePointerMove);
                document.addEventListener('mouseup', handleDaySwipePointerUp);
                document.addEventListener('touchmove', handleDaySwipePointerMove, { passive: false });
                document.addEventListener('touchend', handleDaySwipePointerUp);
            }

            function handleDaySwipePointerMove(e) {
                if (!daySwipeElement) return;

                const coords = getPointerCoordinates(e);
                const deltaX = coords.x - daySwipeStart.x;
                const deltaY = coords.y - daySwipeStart.y;

                if (!isDaySwiping && Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
                    isDaySwiping = true;
                }

                if (isDaySwiping) {
                    if (e.cancelable) e.preventDefault();
                    daySwipeCurrentX = deltaX;
                    daySwipeElement.style.transition = 'none';
                    daySwipeElement.style.transform = `translateX(${daySwipeCurrentX}px)`;
                }
            }

            function handleDaySwipePointerUp(e) {
                document.removeEventListener('mousemove', handleDaySwipePointerMove);
                document.removeEventListener('mouseup', handleDaySwipePointerUp);
                document.removeEventListener('touchmove', handleDaySwipePointerMove);
                document.removeEventListener('touchend', handleDaySwipePointerUp);

                if (!daySwipeElement) return;

                if (isDaySwiping) {
                    const swipeThreshold = daySwipeElement.offsetWidth * 0.25;

                    daySwipeElement.style.transition = 'transform 0.3s ease';
                    daySwipeElement.style.transform = 'translateX(0)';

                    if (daySwipeCurrentX < -swipeThreshold) { // Swiped left for Next Day
                        const today = new Date(); today.setHours(0, 0, 0, 0);
                        const nextDay = new Date(viewDate); nextDay.setDate(nextDay.getDate() + 1);
                        if (nextDay.getTime() <= today.getTime()) {
                            viewDate.setDate(viewDate.getDate() + 1);
                            updateDayView(viewDate);
                        }
                    } else if (daySwipeCurrentX > swipeThreshold) { // Swiped right for Previous Day
                        viewDate.setDate(viewDate.getDate() - 1);
                        updateDayView(viewDate);
                    }
                }

                isDaySwiping = false;

                setTimeout(() => {
                    if(daySwipeElement) {
                       daySwipeElement.style.transition = '';
                       daySwipeElement.style.transform = '';
                    }
                    daySwipeElement = null;
                }, 300);
            }

            ui.dailySummaryCard.addEventListener('mousedown', handleDaySwipePointerDown);
            ui.dailySummaryCard.addEventListener('touchstart', handleDaySwipePointerDown, { passive: true });

            // --- ADDITIONAL LISTENERS ---
            const resetToToday = () => {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                updateDayView(today);
            };
            ui.dayViewTitleSpan.addEventListener('click', resetToToday);
            ui.dayViewDateSpan.addEventListener('click', resetToToday);

            ui.undoToastBtn.addEventListener('click', () => {
                if(!lastAction) return;
                const dayLog = getDayLog(viewDate);

                if(lastAction.type === 'delete') {
                    dayLog.entries.splice(lastAction.data.index, 0, lastAction.data.item);
                } else if (lastAction.type === 'edit') {
                    dayLog.entries[lastAction.data.index] = lastAction.data.originalItem;
                } else if (lastAction.type === 'water') {
                    dayLog.water = lastAction.data.originalWater;
                }

                saveData();
                fullRender();
                hideUndo();
            });

            // --- INITIALIZATION ---
            loadData();
            updateDayView(viewDate);
            // Setup carousels on initial load
            setupCarousel('ai-scanner-results-container', 'ai-scanner-prev', 'ai-scanner-next');
            // setupCarousel('barcode-results', 'barcode-scanner-prev', 'barcode-scanner-next'); // Removed
            // setupCarousel('ingredient-list-container', 'recipe-prev-ingredient', 'recipe-next-ingredient'); // Removed
        });
    </script>
</body>
</html>

