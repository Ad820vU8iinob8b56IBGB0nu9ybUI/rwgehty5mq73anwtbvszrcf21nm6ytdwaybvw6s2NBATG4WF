<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-AR">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FitTrack AI | Nutrition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Added for barcode scanning -->
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    <style>
        :root {
            --background: #000000;
            --primary-text: #eaeaea;
            --secondary-text: #888888;
            --card-bg: #111111;
            --input-bg: #191919;
            --border-color: #222222;
            --accent: #FFFFFF;
            --accent-hover: #DDDDDD;
            --danger: #E53E3E;
            --edit: #3b82f6;
            --nav-footer-height: 64px; /* Set height of the new fixed footer nav */
        }

        html, body {
            overscroll-behavior-y: contain;
            /* Ensure content has room above the fixed footer */
            padding-bottom: var(--nav-footer-height);
        }

        body {
            background-color: var(--background);
            color: var(--primary-text);
            font-family: 'Manrope', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        h1, h2, h3, h4, h5, h6 {
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .nav-link {
            /* Styles for the footer navigation links */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex-grow: 1;
            height: 100%;
            transition: color 0.3s ease;
            color: var(--secondary-text);
            font-size: 0.75rem;
            text-decoration: none;
            padding-top: 4px;
        }

        .nav-link:hover {
            color: var(--primary-text);
        }

        .nav-link.active {
            color: var(--primary-text);
        }

        .nav-link.active .nav-icon {
            color: var(--primary-text);
        }

        .nav-icon {
            margin-bottom: 2px;
            width: 24px;
            height: 24px;
        }

        #mobile-footer-nav {
            background-color: var(--card-bg); /* Ensure it is fully opaque */
        }

        .content-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 1.5rem;
        }

        .form-input {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            color: var(--primary-text);
            padding: 0.75rem 1rem;
            width: 100%;
            transition: all 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
        }

        .form-input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .form-label {
            color: var(--secondary-text);
            font-size: 0.875rem;
            font-weight: 500;
        }

        .btn {
            border-radius: 0.5rem;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            transition: all 0.2s ease-in-out;
            text-align: center;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            transform: translateY(0);
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: translateY(0);
        }

        /* NEW: Water Button Styles */
        #add-water-btn {
            position: relative;
            overflow: hidden;
            /* Ensure gestures are captured */
            touch-action: none;
        }
        #water-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            background-color: #3b82f6; /* Blue fill */
            height: 0%; /* Starts at 0 */
            /* This transition provides the fill animation */
            transition: height 0.3s ease-out;
            z-index: 1;
        }
        #add-water-btn > i {
            position: relative;
            z-index: 2;
             /* Add a subtle shadow to make icon pop */
            filter: drop-shadow(0 1px 1px rgba(0,0,0,0.4));
        }
        /* END: Water Button Styles */

        .btn-primary {
            background-color: var(--accent);
            color: var(--background);
        }

        .btn-primary:hover:not(:disabled) {
            background-color: var(--accent-hover);
        }

        .btn-secondary {
            background-color: transparent;
            border: 1px solid var(--border-color);
            color: var(--primary-text);
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: var(--border-color);
            border-color: var(--accent);
        }

        .btn-danger {
            background-color: var(--danger);
            color: var(--primary-text);
        }

        .btn-danger:hover:not(:disabled) {
             background-color: #C53030;
        }

        .modal-backdrop {
            display: none;
            position: fixed;
            z-index: 50;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease;
            /* Added for mobile full-screen modals */
            padding: 0;
        }

        /* Standard modal content */
        .modal-content {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            padding: 2rem;
            border-radius: 0.75rem;
            width: 90%;
            max-width: 550px;
            max-height: 90vh;
            overflow-y: auto;
            animation: slideIn 0.3s ease;
            position: relative; /* Added for absolute positioning of close button */
        }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideIn { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

        .loader {
            border: 2px solid #333;
            border-top: 2px solid var(--accent);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: var(--input-bg); border-radius: 3px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #666; }

        details > summary { list-style: none; }
        details > summary::-webkit-details-marker { display: none; }

        /* Style for details summary */
        details summary {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding-bottom: 0.5rem;
        }
        details summary .chevron {
            transition: transform 0.2s ease;
        }
        details[open] summary .chevron {
            transform: rotate(180deg);
        }


        /* Prevents number input arrows */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
          -webkit-appearance: none;
          margin: 0;
        }
        input[type=number] {
          -moz-appearance: textfield;
        }

        /* Swipe gesture styles */
        .swipe-item {
            position: relative;
            overflow: hidden;
            user-select: none;
        }
        .swipe-actions {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
        }
        .swipe-action-container {
            position: absolute;
            top: 0; bottom: 0;
            width: 100%;
            display: flex;
            align-items: center;
            opacity: 0; /* Hidden by default */
            transition: opacity 0.3s ease;
        }
        .swipe-action-container.left { /* Delete */
            justify-content: flex-start;
            background: linear-gradient(to right, hsl(0, 72%, 51%), hsl(0, 82%, 61%));
        }
        .swipe-action-container.right { /* Edit */
            justify-content: flex-end;
            background: linear-gradient(to left, hsl(217, 91%, 60%), hsl(217, 81%, 70%));
        }
        .swipe-actions .action {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            padding: 0 1.5rem;
        }
        .swipe-content {
            position: relative;
            background-color: var(--card-bg); /* Use card background for swipable item */
            touch-action: pan-y; /* Allow vertical scroll while capturing horizontal */
            cursor: pointer;
        }
        .swipe-content.swiping {
            transition: none; /* No transition while actively dragging */
        }
        .swipe-content.returning {
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        /* NEW styles for water button swipe */
        #water-swipe-content.swiping { transition: none; }
        #water-swipe-content.returning { transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        #add-water-btn:hover:not(:disabled) #water-swipe-content {
             background-color: var(--border-color);
        }

        /* Carousel Styles */
        .carousel-wrapper {
            position: relative;
            width: 100%;
            margin: 0 auto;
        }
        .carousel-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
            background-color: rgba(17, 17, 17, 0.7);
            color: var(--primary-text);
            border: 1px solid var(--border-color);
            border-radius: 9999px;
            width: 2.5rem;
            height: 2.5rem;
            display: none; /* Initially hidden, controlled by JS */
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
            cursor: pointer;
        }
        .carousel-btn:hover {
            background-color: var(--input-bg);
        }
        /* Adjusted positioning for better tap targets */
        .carousel-prev { left: -0.75rem; }
        .carousel-next { right: -0.75rem; }

        .horizontal-scroll-container {
            display: flex;
            /* FIX 1: Ensure flex row layout */
            flex-direction: row;
            flex-wrap: nowrap;
            overflow-x: auto;
            scroll-behavior: smooth;
            scroll-snap-type: x mandatory;
            gap: 1rem;
            padding-top: 1rem;
            padding-bottom: 1rem;
            /* Hide scrollbars */
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .horizontal-scroll-container::-webkit-scrollbar {
            display: none;
        }
        .scroll-item {
            flex: 0 0 85%; /* Default item width */
            width: 85%;
            scroll-snap-align: center;
            white-space: normal;
        }
        /* Centering padding */
        .horizontal-scroll-container::before,
        .horizontal-scroll-container::after {
            content: '';
            /* Adjust width calculation based on the default item width (85%) */
            width: calc((100% - 85%) / 2 - 0.5rem);
            flex-shrink: 0;
        }

        /* Wider items for scanner carousels */
        .scanner-carousel .scroll-item {
            flex: 0 0 95%; /* Make scanner items wider */
            width: 95%;
        }
        .scanner-carousel::before,
        .scanner-carousel::after {
             /* Adjust width calculation based on the scanner item width (95%) */
            width: calc((100% - 95%) / 2 - 0.5rem);
        }

        /* --- NEW: Compound Food Modal Styles --- */
        @media (min-width: 768px) {
            #compound-food-modal .modal-content {
                width: 90vw;
                max-width: 48rem;
                padding: 2rem;
            }
        }
        #recipe-name-input::placeholder {
            color: var(--accent);
            font-weight: 700;
            opacity: 0.8;
        }
        .section-disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        .disabled-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none; /* Hide by default */
            align-items: center;
            justify-content: center;
            background-color: rgba(17, 17, 17, 0.8); /* --card-bg with opacity */
            z-index: 5;
            border-radius: 0.5rem;
            text-align: center;
            padding: 1rem;
            color: var(--primary-text);
            font-weight: 500;
        }
        .section-disabled + .disabled-overlay {
            display: flex;
        }

        /* Scoped scrollbar styles for recipe modal */
        #compound-food-modal .custom-scrollbar {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        #compound-food-modal .custom-scrollbar::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        /* Scoped carousel styles for recipe modal */
        #compound-food-modal .scroll-item {
            flex: 0 0 100%; /* Make items fill width */
            width: 100%;
        }
        #compound-food-modal .horizontal-scroll-container::before,
        #compound-food-modal .horizontal-scroll-container::after {
            content: none; /* Remove side padding */
        }

        .ingredient-row {
            width: 100%;
            white-space: normal;
        }
        .ingredient-number {
            width: 1.5rem;
            height: 1.5rem;
            background-color: var(--accent);
            color: var(--background);
            border-radius: 9999px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: 700;
            flex-shrink: 0; /* Prevent number from shrinking */
        }
        /* --- END: Compound Food Modal Styles --- */

    </style>
</head>
<body class="antialiased">

    <div class="container mx-auto max-w-7xl px-4 py-6">
        <!-- Header -->
        <header class="flex items-center justify-between mb-4 pb-4 border-b border-gray-900">
             <a href="index.html" class="flex items-center gap-3">
                 <!-- Replaced PNG with inline SVG -->
                <svg width="100" height="24" viewBox="0 0 100 24" fill="#FFFFFF" xmlns="http://www.w3.org/2000/svg" style="height: 24px; width: auto;">
                    <style>
                        .logo-text { font-family: 'Manrope', sans-serif; font-size: 20px; font-weight: 700; letter-spacing: 0.05em; }
                        .halo-text { font-family: 'Manrope', sans-serif; font-size: 4px; font-weight: 500; }
                    </style>
                    <text x="6" y="19" class="logo-text">K</text>
                    <!-- Smiley face -->
                    <circle cx="28" cy="12" r="7" fill="#FFFFFF"/>
                    <circle cx="25" cy="10" r="1.5" fill="#000000"/>
                    <circle cx="31" cy="10" r="1.5" fill="#000000"/>
                    <!-- Halo -->
                    <ellipse cx="28" cy="2" rx="6" ry="1" stroke="#FFFFFF" stroke-width="0.8" fill="none"/>
                    <text x="25.5" y="8" class="halo-text" fill="#FFFFFF"></text>
                    <text x="37" y="19" class="logo-text">WBI</text>
                </svg>
            </a>
        </header>
        <!-- Main Content -->
        <main class="grid grid-cols-1 md:grid-cols-2 gap-4">
             <!-- Left Column: Summary -->
            <div class="space-y-8">
                <div id="daily-summary-card" class="content-card">
                    <!-- Date Navigation & Chart -->
                    <div class="flex items-center justify-between mb-4">
                        <div class="text-left">
                            <h3 class="text-xl">
                                <span id="day-view-title-span" class="block text-2xl font-bold cursor-pointer">Today</span>
                                <span id="day-view-date-span" class="text-base  text-secondary-text cursor-pointer"></span>
                            </h3>
                        </div>
                        <div class="w-16 h-16">
                            <canvas id="macro-chart"></canvas>
                        </div>
                    </div>
                    <div class="w-full grid grid-cols-2 gap-x-6 gap-y-2 text-xs sm:text-sm">
                        <div class="flex justify-between items-baseline"><span class="text-gray-400">Calories:</span> <span class="font-semibold"><span id="current-calories">0</span> / <span id="goal-calories">2000</span></span></div>
                        <div class="flex justify-between items-baseline"><span class="text-gray-400">Protein:</span> <span class="font-semibold"><span id="current-protein">0</span> / <span id="goal-protein">150</span> g</span></div>
                        <div class="flex justify-between items-baseline"><span class="text-gray-400">Carbs:</span> <span class="font-semibold"><span id="current-carbs">0</span> / <span id="goal-carbs">225</span> g</span></div>
                        <div class="flex justify-between items-baseline"><span class="text-gray-400">Fat:</span> <span class="font-semibold"><span id="current-fat">0</span> / <span id="goal-fat">60</span> g</span></div>
                        <div class="flex justify-between items-baseline"><span class="text-gray-400">Na:</span> <span class="font-semibold"><span id="current-sodium">0</span> / <span id="goal-sodium">2300</span> mg</span></div>
                        <div class="flex justify-between items-baseline"><span class="text-gray-400">K:</span> <span class="font-semibold"><span id="current-potassium">0</span> / <span id="goal-potassium">3500</span> mg</span></div>
                        <div class="flex justify-between items-baseline"><span class="text-gray-400">Sugar:</span> <span class="font-semibold"><span id="current-sugar">0</span> / <span id="goal-sugar">50</span> g</span></div>
                        <div class="flex justify-between items-baseline"><span class="text-gray-400">Water:</span> <span class="font-semibold"><span id="current-water">0</span> / <span id="goal-water">2500</span> ml</span></div>
                    </div>
                </div>
            </div>
            <!-- Right Column: Logging & Food Log -->
            <div class="space-y-4">
                <div class="content-card">
                    <h3 class="text-2xl font-bold mb-6">Log Your Meal</h3>
                    <form id="log-meal-form" class="space-y-4">
                        <div>
                            <label for="food-name-input" class="form-label">Food Name *</label>
                            <input type="text" id="food-name-input" list="favorite-foods-datalist" placeholder="e.g., Chicken Breast" class="form-input mt-1">
                            <datalist id="favorite-foods-datalist"></datalist>
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label for="food-servings-input" class="form-label">Servings *</label>
                                <input type="number" id="food-servings-input" placeholder="1" value="1" min="0" step="0.1" class="form-input mt-1">
                            </div>
                            <div>
                                <label for="food-brand-input" class="form-label">Brand (Optional)</label>
                                <input type="text" id="food-brand-input" placeholder="e.g., Tesco" class="form-input mt-1">
                            </div>
                        </div>
                        <details class="pt-2">
                            <summary class="cursor-pointer text-sm text-gray-400 hover:text-white flex items-center justify-between">
                                <span>Enter Macros for 1 Serving</span>
                                <i data-lucide="chevron-down" class="w-4 h-4 chevron"></i>
                            </summary>
                            <div class="space-y-3 pt-2 mt-2 border-t border-gray-800">
                                <div class="grid grid-cols-4 gap-2">
                                    <div>
                                        <label class="form-label text-xs">Calories</label>
                                        <input type="number" step="0.01" id="food-calories-input" min="0" placeholder="kcal" class="form-input mt-1 !py-1.5 text-sm macro-input">
                                    </div>
                                    <div>
                                        <label class="form-label text-xs">Protein</label>
                                        <input type="number" step="0.01" id="food-protein-input" min="0" placeholder="g" class="form-input mt-1 !py-1.5 text-sm macro-input">
                                    </div>
                                    <div>
                                        <label class="form-label text-xs">Fat</label>
                                        <input type="number" step="0.01" id="food-fat-input" min="0" placeholder="g" class="form-input mt-1 !py-1.5 text-sm macro-input">
                                    </div>
                                    <div>
                                        <label class="form-label text-xs">Carbs</label>
                                        <input type="number" step="0.01" id="food-carbs-input" min="0" placeholder="g" class="form-input mt-1 !py-1.5 text-sm macro-input">
                                    </div>
                                </div>
                                <div class="grid grid-cols-4 gap-2">
                                    <div>
                                        <label class="form-label text-xs">Sugar</label>
                                        <input type="number" step="0.01" id="food-sugar-input" min="0" placeholder="g" class="form-input mt-1 !py-1.5 text-sm macro-input">
                                    </div>
                                    <div>
                                        <label class="form-label text-xs">Potassium</label>
                                        <input type="number" step="0.01" id="food-potassium-input" min="0" placeholder="mg" class="form-input mt-1 !py-1.5 text-sm macro-input">
                                    </div>
                                    <div>
                                        <label class="form-label text-xs">Sodium</label>
                                        <input type="number" step="0.01" id="food-sodium-input" min="0" placeholder="mg" class="form-input mt-1 !py-1.5 text-sm macro-input">
                                    </div>
                                    <div>
                                        <label for="food-grams-input" class="form-label text-xs">Grams</label>
                                        <input type="number" id="food-grams-input" placeholder="g" min="0" class="form-input mt-1 !py-1.5 text-sm">
                                    </div>
                                </div>
                            </div>
                        </details>
                        <!-- Updated Button Grid -->
                        <div class="grid grid-cols-5 gap-2 sm:gap-4"> <!-- MODIFIED: to 5 cols -->
                            <!-- Compound Food/Recipe Button -->
                            <button id="open-compound-food-modal-btn" type="button" class="btn btn-secondary !p-2 sm:!p-3" title="Build a Recipe">
                                <i data-lucide="chef-hat" class="w-4 h-4 sm:w-5 sm:h-5"></i> <!-- Changed icon to chef-hat -->
                            </button>
                            <!-- NEW: AI Macro Swap Button -->
                            <button id="ai-macro-swap-btn" type="button" class="btn btn-secondary !p-2 sm:!p-3" title="AI Macro Swap">
                                <i data-lucide="replace" class="w-4 h-4 sm:w-5 sm:h-5 btn-text"></i>
                                <div class="loader hidden"></div>
                            </button>
                            <!-- Add Food (AI Lookup) Button -->
                            <button id="add-food-btn" type="button" class="btn btn-primary !p-2 sm:!p-3" title="Add Food / AI Lookup">
                                <i data-lucide="sparkles" class="w-4 h-4 sm:w-5 sm:h-5 btn-text"></i>
                                <div class="loader hidden"></div>
                            </button>
                            <!-- Combined Scan Button -->
                            <button id="scan-combined-btn" type="button" class="btn btn-secondary !p-2 sm:!p-3" title="Scan Barcode or Food"><i data-lucide="scan-line" class="w-4 h-4 sm:w-5 sm:h-5"></i></button>
                            <!-- Log Water Button -->
                            <button id="add-water-btn" type="button" class="btn btn-secondary !p-0 !p-0 sm:!p-0 !relative !overflow-hidden" title="Log Water (Tap, Swipe Up/Down, Swipe Left/Right)">
                                <!-- Swipe backgrounds -->
                                <div id="water-swipe-actions" class="swipe-actions">
                                    <!-- NEW: Purple swipe down background -->
                                    <div id="water-swipe-bg-top" class="swipe-action-container !items-start !justify-center" style="opacity: 0; background: linear-gradient(to bottom, hsl(262, 83%, 60%), hsl(262, 83%, 70%)); height: 0; transition: height 0.3s ease; top: 0; left: 0; right: 0; bottom: auto;">
                                        <!-- Centered the icon using !justify-center -->
                                        <div class="action !h-auto py-3 !justify-center"><i data-lucide="target" class="w-4 h-4 sm:w-5 sm:h-5 pointer-events-none"></i></div>
                                    </div>
                                    <!-- MODIFIED: Green swipe left background -->
                                    <div id="water-swipe-bg-left" class="swipe-action-container left !justify-start" style="opacity: 0; background: linear-gradient(to right, hsl(145, 63%, 49%), hsl(145, 63%, 59%));">
                                        <div class="action"><i data-lucide="edit-3" class="w-4 h-4 sm:w-5 sm:h-5 pointer-events-none"></i></div>
                                    </div>
                                    <div id="water-swipe-bg-right" class="swipe-action-container right !justify-end" style="opacity: 0; background: linear-gradient(to left, hsl(0, 82%, 61%), hsl(0, 72%, 51%));">
                                        <div class="action"><i data-lucide="minus" class="w-4 h-4 sm:w-5 sm:h-5 pointer-events-none"></i></div>
                                    </div>
                                </div>

                                <!-- This is the part that moves -->
                                <div id="water-swipe-content" class="swipe-content relative w-full h-full flex items-center justify-center !p-2 sm:!p-3 !bg-transparent transition-colors duration-200">
                                    <span id="water-fill"></span> <!-- Fill element -->
                                    <i data-lucide="glass-water" class="w-4 h-4 sm:w-5 sm:h-5 relative z-10"></i> <!-- Icon on top -->
                                </div>
                            </button>
                        </div>
                        <div id="add-food-error" class="text-red-400 text-sm mt-2"></div>
                    </form>
                </div>
                <!-- Daily Log Content & AI Report Output -->
                <div class="content-card">
                     <div class="flex justify-between items-center mb-4">
                         <h3 class="text-2xl font-bold">Daily Log</h3>
                         <div class="flex items-center gap-2">
                             <button id="ai-daily-report-btn" class="btn btn-secondary !p-2" title="Get Daily AI Report">
                                 <i data-lucide="clipboard-list" class="w-5 h-5 btn-text"></i>
                                 <div class="loader hidden !w-5 !h-5"></div>
                             </button>
                             <button id="ai-meal-suggester-btn" class="btn btn-secondary !p-2" title="AI Meal Suggester"><i data-lucide="lightbulb" class="w-5 h-5"></i></button>
                             <button id="open-nutritionist-chat-btn" class="btn btn-secondary !p-2" title="Chat with AI Nutritionist"><i data-lucide="message-circle" class="w-5 h-5"></i></button>
                         </div>
                    </div>
                    <div id="daily-log-content" class="space-y-2 max-h-60 overflow-y-auto custom-scrollbar pr-2"><p class="text-gray-500">No food logged yet.</p></div>
                </div>
                <!-- Favorites & Recipes -->
                <div class="content-card">
                    <h3 class="text-2xl font-bold mb-4">Favorites & Recipes</h3>
                    <div id="saved-items-list" class="space-y-2 max-h-60 overflow-y-auto custom-scrollbar pr-2"><p class="text-gray-500 text-center">No saved items yet.</p></div>
                </div>
            </div>
        </main>
    </div>

    <!--
      TEMPLATE FOR A NEW INGREDIENT ROW
    -->
    <template id="ingredient-row-template">
      <!-- RE-ADDED 'scroll-item' class -->
      <div class="scroll-item ingredient-row bg-input-bg rounded-lg space-y-2 p-3">
        <!-- MODIFICATION: Swapped Qty and Ingredient Name -->
        <div class="flex items-end gap-2">
            <!-- Ingredient Name Input -->
            <div class="flex-grow">
                <!-- Labels and Inputs will get unique IDs from JS -->
                <label class="form-label text-xs">Ingredient Name</label>
                <input type="text" list="favorite-foods-datalist" placeholder="e.g., Chicken" class="form-input ingredient-name text-sm !py-1.5" value="">
            </div>
            <!-- Quantity Input -->
            <div class="flex-shrink-0 w-16">
                <label class="form-label text-xs">Qty</label>
                <input type="number" min="0" placeholder="Qty" class="form-input ingredient-quantity text-sm !py-1.5" value="1">
            </div>
        </div>
        <div class="grid grid-cols-4 gap-2">
            <!-- MODIFICATION: Changed all macro inputs from !py-1 to !py-1.5 -->
            <div><label class="form-label text-xs">Calories</label><input type="number" step="0.01" min="0" placeholder="kcal" class="form-input ingredient-calories text-xs !py-1.5" value=""></div>
            <div><label class="form-label text-xs">Protein</label><input type="number" step="0.01" min="0" placeholder="g" class="form-input ingredient-protein text-xs !py-1.5" value=""></div>
            <div><label class="form-label text-xs">Carbs</label><input type="number" step="0.01" min="0" placeholder="g" class="form-input ingredient-carbs text-xs !py-1.5" value=""></div>
            <div><label class="form-label text-xs">Fat</label><input type="number" step="0.01" min="0" placeholder="g" class="form-input ingredient-fat text-xs !py-1.5" value=""></div>
        </div>
         <div class="grid grid-cols-4 gap-2">
            <!-- MODIFICATION: Changed all macro inputs from !py-1 to !py-1.5 -->
            <div><label class="form-label text-xs">Sugar</label><input type="number" step="0.01" min="0" placeholder="g" class="form-input ingredient-sugar text-xs !py-1.5" value=""></div>
            <div><label class="form-label text-xs">Sodium</label><input type="number" step="0.01" min="0" placeholder="mg" class="form-input ingredient-sodium text-xs !py-1.5" value=""></div>
            <div><label class="form-label text-xs">Potassium</label><input type="number" step="0.01" min="0" placeholder="mg" class="form-input ingredient-potassium text-xs !py-1.5" value=""></div>
            <!-- MODIFICATION: Replaced ingredient number with 'Grams' input, styled to match grid (text-xs !py-1.5) -->
            <div>
                <label class="form-label text-xs">Grams</label>
                <input type="number" placeholder="g" min="0" class="form-input ingredient-grams text-xs !py-1.5" value="">
            </div>
        </div>
        <!-- MODIFICATION: Changed to justify-between, wrapped buttons, and added ingredient number at the end -->
        <div class="flex justify-between items-center gap-2">
            <!-- MODIFICATION: Added spacer div to balance the ingredient number for centering -->
            <div class="flex-shrink-0" style="width: 1.5rem; height: 1.5rem;"></div>

            <!-- This div groups buttons and centers them in the available space -->
            <div class="flex-grow flex justify-center items-center gap-2">
                <!-- UPDATED: recipe-scan-btn now uses scan-line icon -->
                <button type="button" class="recipe-scan-btn btn btn-secondary !p-2 flex-shrink-0" title="Scan Ingredient"><i data-lucide="scan-line" class="w-4 h-4 pointer-events-none"></i></button>
                <button type="button" class="remove-ingredient-btn btn btn-secondary !p-2 flex-shrink-0" title="Remove Ingredient"><i data-lucide="x" class="w-4 h-4 pointer-events-none"></i></button>
                <!-- MODIFICATION: Reverted to btn-secondary, removed data-ai-enabled, updated title -->
                <button type="button" class="find-macros-ai-btn btn btn-secondary !p-2 flex-shrink-0" title="Find Macros with AI">
                    <i data-lucide="sparkles" class="w-4 h-4 pointer-events-none lucide-icon"></i>
                    <div class="loader hidden !w-4 !h-4"></div>
                </button>
            </div>
            <!-- Ingredient number is now at the end of this flex row -->
            <span class="ingredient-number">1</span>
        </div>
       </div>
    </template>
    <!-- End Template -->


    <!-- Extracted Compound Food Modal -->
    <div id="compound-food-modal" class="modal-backdrop" style="display: none;">
        <!-- modal-content is (flex flex-col overflow-hidden) -->
        <div class="modal-content">
            <!-- UPDATED: Button moved out of header, made absolute and positioned in the top-right corner -->
            <button id="close-compound-food-modal-btn" class="absolute top-8 right-4 md:top-8 md:right-4 text-gray-400 hover:text-white text-5xl w-8 h-8 flex items-center justify-center z-10">&times;</button>

            <!-- Modal Header (Non-scrolling) -->
            <div class="flex-shrink-0 flex justify-between items-center mb-2">
                <!-- Added spacer div for centering, w-8 (2rem) -->
                <div class="w-8 flex-shrink-0"></div>

                <!-- Replaced h2 with the recipe-name-input, removed mr-4 -->
                <input type="text" id="recipe-name-input" form="compound-food-form" class="form-input !py-1.5 text-1xl font-bold flex-grow text-center" required placeholder="Build Your Creation">

                <!-- Replaced button with a matching spacer to keep input centered -->
                <div class="w-8 flex-shrink-0"></div>
            </div>

            <!-- Scrollable Content Area -->
            <div class="flex-grow overflow-y-auto custom-scrollbar pr-2 mb-4">
                <form id="compound-food-form" class="space-y-4">

                    <div class="border-gray-800">
                        <h3 class="font-semibold text-sm text-center mb-2">Ingredients</h3>
                        <div id="recipe-carousel-wrapper" class="carousel-wrapper">
                            <button id="recipe-prev-ingredient" type="button" class="carousel-btn carousel-prev"><i data-lucide="chevron-left"></i></button>
                            <div id="ingredient-list-container" class="horizontal-scroll-container recipe-carousel items-start border border-gray-700 rounded-lg p-2 section-disabled">
                                <!-- INGREDIENT ROWS Will be added here by JS -->
                            </div>
                            <!-- Added overlay -->
                            <div class="disabled-overlay">
                                <p class="flex items-center gap-2 text-sm"><i data-lucide="arrow-up" class="w-4 h-4 -mt-1"></i> Enter a name above to start</p>
                            </div>
                            <button id="recipe-next-ingredient" type="button" class="carousel-btn carousel-next"><i data-lucide="chevron-right"></i></button>
                        </div>
                    </div>

                    <!-- Totals Container (now inside form, will scroll) -->
                    <div id="recipe-totals-container" class="flex-shrink-0 border-gray-800 px-2 ">
                        <h3 class="text-lg font-semibold text-center mb-2">Total Macros</h3>
                        <div id="recipe-totals" class="grid grid-cols-4 gap-x-2 gap-y-3 text-center">
                            <div><p class="text-xs text-gray-400">Calories</p><p id="recipe-total-calories" class="font-bold text-sm">0</p></div>
                            <div><p class="text-xs text-gray-400">Protein</p><p class="font-bold text-sm"><span id="recipe-total-protein">0</span>g</p></div>
                            <div><p class="text-xs text-gray-400">Carbs</p><p class="font-bold text-sm"><span id="recipe-total-carbs">0</span>g</p></div>
                            <div><p class="text-xs text-gray-400">Fat</p><p class="font-bold text-sm"><span id="recipe-total-fat">0</span>g</p></div>
                            <div><p class="text-xs text-gray-400">Grams</p><p id="recipe-total-grams" class="font-bold text-sm">0</p></div>
                            <div><p class="text-xs text-gray-400">Sugar</p><p class="font-bold text-sm"><span id="recipe-total-sugar">0</span>g</p></div>
                            <div><p class="text-xs text-gray-400">Sodium</p><p class="font-bold text-sm"><span id="recipe-total-sodium">0</span>mg</p></div>
                            <div><p class="text-xs text-gray-400">Potassium</p><p class="font-bold text-sm"><span id="recipe-total-potassium">0</span>mg</p></div>
                        </div>
                    </div>
                </form> <!-- End of Form -->
            </div> <!-- End of Scrollable Area -->

            <!-- Sticky Footer / Action Bar (Non-scrolling) -->
            <div class="flex-shrink-0 border-gray-800">
                <div class="grid grid-cols-2 gap-2 mt-2">
                    <!-- Added disabled attribute -->
                    <button type="button" id="add-ingredient-btn" class="btn btn-secondary w-full !py-1 !text-sm" disabled><i data-lucide="plus"></i>Add Ingredient</button>
                    <button type="submit" form="compound-food-form" id="save-recipe-btn" class="btn btn-primary w-full !py-1 !text-sm">Save & Log Recipe</button>
                </div>
            </div>
        </div>
    </div>
    <!-- End Extracted Modal -->


    <!-- Modals -->

    <!-- Renamed and Unified AI Scanner Modal -->
    <div id="ai-scanner-modal" class="modal-backdrop" style="z-index: 60;">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold">AI Scanner</h2>
                <button id="close-ai-scanner-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <div class="space-y-4">
                <div id="ai-scanner-initial-options" class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <label for="ai-upload-photo-input" class="btn btn-secondary cursor-pointer"><i data-lucide="upload"></i>Upload (Food or Barcode)</label>
                    <input type="file" id="ai-upload-photo-input" class="hidden" accept="image/*" multiple>
                    <button id="start-ai-camera-btn" class="btn bg-white text-black hover:bg-gray-200"><i data-lucide="camera"></i>Start Live Camera</button>
                </div>
                <div id="ai-live-camera-container" class="hidden space-y-2">
                    <video id="ai-camera-video" class="w-full rounded-lg border border-border-color" autoplay playsinline></video>
                    <canvas id="ai-camera-canvas" class="hidden"></canvas> <!-- For capturing frames -->
                    <button id="capture-ai-photo-btn" class="btn btn-primary w-full">Capture Photo</button>
                    <button id="stop-ai-camera-btn" class="btn btn-danger w-full">Close Camera</button>
                </div>
                <p id="ai-scanner-status" class="text-center text-secondary-text text-sm min-h-[1.25rem]"></p>
                <div id="ai-scanner-carousel-wrapper" class="carousel-wrapper hidden">
                    <button id="ai-scanner-prev" type="button" class="carousel-btn carousel-prev"><i data-lucide="chevron-left"></i></button>
                    <!-- FIX 1: Added !flex !flex-row !flex-nowrap to enforce horizontal scrolling -->
                    <div id="ai-scanner-results-container" class="horizontal-scroll-container scanner-carousel mt-4 min-h-[220px] !flex !flex-row !flex-nowrap">
                        <!-- Results injected here -->
                    </div>
                    <button id="ai-scanner-next" type="button" class="carousel-btn carousel-next"><i data-lucide="chevron-right"></i></button>
                </div>
                </div>
            </div>
        </div>
    </div>

    <!-- START: RE-ADDED MODALS -->

    <!-- AI Nutritionist Chat Modal -->
    <div id="ai-nutritionist-modal" class="modal-backdrop" style="z-index: 70;">
        <div class="modal-content !h-[90vh] !max-h-[800px] flex flex-col">
            <div class="flex justify-between items-center mb-4 pb-4 border-b border-border-color">
                <h2 class="text-2xl font-bold flex items-center gap-2"><i data-lucide="bot" class="w-6 h-6 text-blue-400"></i>AI Nutritionist</h2>
                <button id="close-ai-nutritionist-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <div id="ai-chat-history" class="flex-grow overflow-y-auto space-y-4 pr-2 custom-scrollbar">
                <!-- Chat history will be rendered here -->
            </div>
            <div class="mt-4 pt-4 border-t border-border-color flex gap-2">
                <input type="text" id="ai-chat-input" class="form-input flex-grow" placeholder="Ask about your diet...">
                <button id="ai-chat-send-btn" class="btn btn-primary !p-3"><i data-lucide="send" class="w-5 h-5"></i></button>
            </div>
        </div>
    </div>

    <!-- Edit Favorite Modal -->
    <div id="edit-favorite-modal" class="modal-backdrop">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">Edit Favorite Food</h2>
                <button id="close-edit-favorite-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <form id="edit-favorite-form" class="space-y-4">
                <div>
                    <label for="edit-fav-food-name" class="form-label">Food Name (100g serving)</label>
                    <input type="text" id="edit-fav-food-name" class="form-input mt-1" required>
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label for="edit-fav-food-calories" class="form-label">Calories</label>
                        <input type="number" step="0.01" id="edit-fav-food-calories" class="form-input mt-1" required>
                    </div>
                    <div>
                        <label for="edit-fav-food-protein" class="form-label">Protein (g)</label>
                        <input type="number" step="0.01" id="edit-fav-food-protein" class="form-input mt-1" required>
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label for="edit-fav-food-carbs" class="form-label">Carbs (g)</label>
                        <input type="number" step="0.01" id="edit-fav-food-carbs" class="form-input mt-1" required>
                    </div>
                    <div>
                        <label for="edit-fav-food-fat" class="form-label">Fat (g)</label>
                        <input type="number" step="0.01" id="edit-fav-food-fat" class="form-input mt-1" required>
                    </div>
                </div>
                <!-- Optional micronutrients -->
                <details class="pt-2">
                    <summary class="cursor-pointer text-sm text-gray-400 hover:text-white">Optional Macros (per 100g)</summary>
                    <div class="grid grid-cols-3 gap-3 pt-3">
                        <div>
                            <label for="edit-fav-food-sugar" class="form-label text-xs">Sugar (g)</label>
                            <input type="number" step="0.01" id="edit-fav-food-sugar" class="form-input mt-1 !py-1.5 text-sm">
                        </div>
                        <div>
                            <label for="edit-fav-food-sodium" class="form-label text-xs">Sodium (mg)</label>
                            <input type="number" step="0.01" id="edit-fav-food-sodium" class="form-input mt-1 !py-1.5 text-sm">
                        </div>
                        <div>
                            <label for="edit-fav-food-potassium" class="form-label text-xs">Potassium (mg)</label>
                            <input type="number" step="0.01" id="edit-fav-food-potassium" class="form-input mt-1 !py-1.5 text-sm">
                        </div>
                    </div>
                </details>
                <button type="submit" class="btn btn-primary w-full mt-4">Save Changes</button>
            </form>
        </div>
    </div>

    <!-- Generic Alert Modal -->
    <div id="alert-modal" class="modal-backdrop" style="z-index: 80;">
        <div class="modal-content">
            <h2 id="alert-modal-title" class="text-2xl font-bold mb-4">Alert</h2>
            <p id="alert-modal-text" class="text-gray-300 mb-6"></p>
            <button id="alert-modal-ok-btn" class="btn btn-primary w-full">OK</button>
        </div>
    </div>

    <!-- Generic Confirm Modal -->
    <div id="confirm-modal" class="modal-backdrop" style="z-index: 80;">
        <div class="modal-content">
            <h2 id="confirm-modal-title" class="text-2xl font-bold mb-4">Confirm</h2>
            <p id="confirm-modal-text" class="text-gray-300 mb-6"></p>
            <div class="flex gap-4">
                <button id="confirm-modal-cancel-btn" class="btn btn-secondary w-full">Cancel</button>
                <button id="confirm-modal-confirm-btn" class="btn btn-danger w-full">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Generic Prompt Modal -->
    <div id="prompt-modal" class="modal-backdrop" style="z-index: 80;">
        <div class="modal-content">
            <h2 id="prompt-modal-title" class="text-2xl font-bold mb-4">Input</h2>
            <p id="prompt-modal-text" class="text-gray-300 mb-4"></p>
            <input type="text" id="prompt-modal-input" class="form-input w-full">
            <div class="flex gap-4 mt-6">
                <button id="prompt-modal-cancel-btn" class="btn btn-secondary w-full">Cancel</button>
                <button id="prompt-modal-ok-btn" class="btn btn-primary w-full">OK</button>
            </div>
        </div>
    </div>

    <!-- AI Daily Report Modal -->
    <div id="ai-report-modal" class="modal-backdrop">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold flex items-center gap-2"><i data-lucide="clipboard-list" class="w-5 h-5 text-blue-400"></i>Daily AI Report</h2>
                <button id="close-ai-report-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <div id="ai-report-modal-text" class="text-gray-300 max-h-60 overflow-y-auto custom-scrollbar pr-2"></div>
            <button id="ai-report-modal-ok-btn" class="btn btn-primary w-full mt-6">Got it</button>
        </div>
    </div>

    <!-- AI Meal Suggester Modal -->
    <div id="ai-suggester-modal" class="modal-backdrop">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">AI Meal Suggester</h2>
                <button id="close-ai-suggester-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <p class="text-gray-400 mb-4 text-sm">Enter ingredients you have, and the AI will suggest a quick, healthy meal.</p>
            <div>
                <label for="ai-ingredients-input" class="form-label">Your Ingredients</label>
                <textarea id="ai-ingredients-input" rows="3" class="form-input mt-1" placeholder="e.g., chicken breast, rice, broccoli, olive oil"></textarea>
            </div>
            <button id="ai-suggestion-btn" class="btn btn-secondary w-full mt-4"><span class="btn-text">Generate Ideas</span><div class="loader hidden"></div></button>
            <div id="ai-suggestions-output" class="mt-4 space-y-3"></div>
        </div>
    </div>

    <!-- AI Macro Swap Modal -->
    <div id="ai-macro-swap-modal" class="modal-backdrop">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold flex items-center gap-2"><i data-lucide="replace" class="w-5 h-5 text-blue-400"></i>AI Macro Swap</h2>
                <button id="close-ai-macro-swap-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <p class="text-gray-400 mb-4 text-sm">Healthier alternatives for <strong id="ai-swap-food-name" class="text-white">...</strong></p>
            <div id="ai-macro-swap-output" class="space-y-3 min-h-[150px]">
                <!-- Suggestions will be injected here -->
                <div class="loader mx-auto"></div>
            </div>
        </div>
    </div>

    <!-- END: RE-ADDED MODALS -->

     <!-- Undo Toast -->
    <div id="undo-toast" class="fixed bottom-20 left-1/2 -translate-x-1/2 bg-gray-800 text-white py-2 px-4 rounded-lg shadow-lg flex items-center gap-4 transform translate-y-24 opacity-0 transition-all duration-300 z-[100]">
        <span id="undo-toast-text"></span>
        <button id="undo-toast-btn" class="font-bold text-blue-400 hover:text-blue-300">Undo</button>
    </div>


    <!-- FIXED MOBILE FOOTER NAV BAR -->
    <nav id="mobile-footer-nav" class="fixed bottom-0 left-0 right-0 h-16 bg-card-bg border-t border-border-color z-50 flex justify-around items-center">
        <a href="index.html" class="nav-link">
            <i data-lucide="home" class="nav-icon"></i>
            <span>Home</span>
        </a>
        <a href="nutrition.html" class="nav-link active">
            <i data-lucide="utensils" class="nav-icon"></i>
            <span>Nutrition</span>
        </a>
        <a href="workouts.html" class="nav-link">
            <i data-lucide="dumbbell" class="nav-icon"></i>
            <span>Workouts</span>
        </a>
        <a href="sleep.html" class="nav-link">
            <i data-lucide="moon" class="nav-icon"></i>
            <span>Sleep</span>
        </a>
        <a href="settings.html" class="nav-link">
            <i data-lucide="settings" class="nav-icon"></i>
            <span>Settings</span>
        </a>
    </nav>

    <!-- Hidden helper for html5-qrcode library -->
    <div id="barcode-reader-hidden-helper" class="hidden"></div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- STATE MANAGEMENT ---
            let allDailyLogs = {};
            let goals = { calories: 2000, protein: 150, carbs: 225, fat: 60, sugar: 50, sodium: 2300, potassium: 3500, water: 2500 };
            let userProfile = { goal: 'maintain weight', waterServingSize: 250 };
            let favoriteFoods = [];
            let savedRecipes = [];
            let editingFoodLogIndex = null;
            let editingFavoriteFoodName = null;
            let confirmCallback = null;
            let promptCallback = null;
            let viewDate = new Date();
            viewDate.setHours(0, 0, 0, 0);
            let foodCameraStream = null;
            let aiBaseMacros = null;
            let chatHistory = [];
            let lastScannedBarcode = { code: null, time: 0 };
            let undoTimeout = null;
            let lastAction = null;
            let lastWaterLogAmount = 0; // NEW: Store last water amount for undo
            let openModalCount = 0;
            let activeRecipeScanBtn = null; // Store the button that triggered the scanner for ingredients

            // --- CORE & HELPER FUNCTIONS ---
            function dateToKey(date) { return date.toISOString().split('T')[0]; }
            function capitalizeWords(str) { if (!str) return ''; return str.replace(/\b\w/g, char => char.toUpperCase()); }

            function getDayLog(date) {
                const key = dateToKey(date);
                if (!allDailyLogs[key]) {
                    allDailyLogs[key] = { entries: [], water: 0 };
                }
                // Ensure water exists even if entries array is created
                if (typeof allDailyLogs[key].water === 'undefined') {
                     allDailyLogs[key].water = 0;
                }
                return allDailyLogs[key];
            }

            function getCurrentDayLogEntries() { return getDayLog(viewDate).entries; }

            // --- GEMINI API ---
            const getApiUrl = (model, action = 'generateContent') => {
                 const apiKey = "AIzaSyDY48xF1byvU05kS9qKvN8iyrIR3hheP8w"; // Leave empty for Canvas environment
                 return `https://generativelanguage.googleapis.com/v1beta/models/${model}:${action}?key=${apiKey}`;
            };

            // Helper function to make API calls with exponential backoff
            async function fetchWithBackoff(apiUrl, payload, maxRetries = 3) {
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (response.ok) {
                            const result = await response.json();
                           // Check for expected data in the response structure
                            const hasText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                            const hasImageData = result.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                            const hasStructuredResponse = payload.generationConfig?.responseMimeType === "application/json";

                           if (hasText || hasImageData || hasStructuredResponse) {
                                return result; // Successful and valid response structure
                            } else {
                                console.warn("API response structure unexpected, but status OK:", result);
                                if (i === maxRetries - 1) throw new Error("Invalid API response format after retries.");
                                // Continue retrying if format is wrong, unless last attempt
                            }
                        } else if (response.status === 429 || response.status >= 500) { // Retry on rate limit or server errors
                            if (i === maxRetries - 1) throw new Error(`API Error: ${response.status} after ${maxRetries} attempts.`);
                            const delay = Math.pow(2, i) * 1000 + Math.random() * 1000; // Exponential backoff with jitter
                            await new Promise(resolve => setTimeout(resolve, delay));
                        } else { // Don't retry for other client errors (4xx)
                            throw new Error(`API Error: ${response.status}`);
                        }
                    } catch (error) {
                        console.error(`Fetch attempt ${i + 1} failed:`, error);
                        if (i === maxRetries - 1) throw error; // Re-throw final error
                        const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
                throw new Error("API call failed after all retries.");
            }
            // --- END GEMINI API ---

            // --- Modal show/hide functions ---
            function showModal(modalElement) {
                modalElement.style.display = 'flex';
                if (openModalCount === 0) {
                    document.body.style.overflow = 'hidden';
                }
                openModalCount++;
            }
            function hideModal(modalElement) {
                modalElement.style.display = 'none';
                openModalCount--;
                if (openModalCount <= 0) {
                    document.body.style.overflow = '';
                    openModalCount = 0; // Failsafe
                }
            }
            // --- END Modal functions ---

            function showCustomAlert(title, text) { if (ui.alertModal.style.display === 'flex') return; ui.alertModalTitle.textContent = title; ui.alertModalText.textContent = text; showModal(ui.alertModal); }
            function showConfirmModal(title, text, onConfirm) { if (ui.confirmModal.style.display === 'flex') return; ui.confirmModalTitle.textContent = title; ui.confirmModalText.textContent = text; confirmCallback = onConfirm; showModal(ui.confirmModal); }
            function showPromptModal(title, text, defaultValue, onConfirm) { if (ui.promptModal.style.display === 'flex') return; ui.promptModalTitle.textContent = title; ui.promptModalText.textContent = text; ui.promptModalInput.value = defaultValue; promptCallback = onConfirm; showModal(ui.promptModal); ui.promptModalInput.focus(); ui.promptModalInput.select(); }

            function saveData() {
                localStorage.setItem('fitTrackAI_allDailyLogs', JSON.stringify(allDailyLogs));
                localStorage.setItem('fitTrackAI_userProfile', JSON.stringify(userProfile));
                localStorage.setItem('fitTrackAI_favoriteFoods', JSON.stringify(favoriteFoods));
                localStorage.setItem('fitTrackAI_savedRecipes', JSON.stringify(savedRecipes));
                localStorage.setItem('fitTrackAI_goals', JSON.stringify(goals));
                localStorage.setItem('fitTrackAI_chatHistory', JSON.stringify(chatHistory));
            }

            function loadData() {
                let logs = JSON.parse(localStorage.getItem('fitTrackAI_allDailyLogs')) || {};
                // Migration for old data structure
                for(const date in logs) {
                    if(Array.isArray(logs[date])) {
                        logs[date] = {
                            entries: logs[date].filter(item => item.name !== 'Water'), // Remove old water entries
                            water: 0
                        }
                    }
                    // Ensure water exists after migration or for new logs
                     if (typeof logs[date].water === 'undefined') {
                         logs[date].water = 0;
                     }
                }
                allDailyLogs = logs;

                chatHistory = JSON.parse(localStorage.getItem('fitTrackAI_chatHistory')) || [];
                userProfile = JSON.parse(localStorage.getItem('fitTrackAI_userProfile')) || { goal: 'maintain weight', waterServingSize: 250 };
                goals = JSON.parse(localStorage.getItem('fitTrackAI_goals')) || { calories: 2000, protein: 150, carbs: 225, fat: 60, sugar: 50, sodium: 2300, potassium: 3500, water: 2500 };
                savedRecipes = JSON.parse(localStorage.getItem('fitTrackAI_savedRecipes')) || [];
                favoriteFoods = JSON.parse(localStorage.getItem('fitTrackAI_favoriteFoods')) || [];
            }

            // --- UI ELEMENT DEFINITIONS ---
            const ui = {
                foodNameInput: document.getElementById('food-name-input'), foodBrandInput: document.getElementById('food-brand-input'), foodServingsInput: document.getElementById('food-servings-input'), foodGramsInput: document.getElementById('food-grams-input'), logMealForm: document.getElementById('log-meal-form'), addFoodBtn: document.getElementById('add-food-btn'), addFoodError: document.getElementById('add-food-error'), dailyLogContentDiv: document.getElementById('daily-log-content'),

                foodScannerModal: document.getElementById('ai-scanner-modal'),
                closeFoodScannerModalBtn: document.getElementById('close-ai-scanner-modal-btn'),
                uploadPhotoInput: document.getElementById('ai-upload-photo-input'),
                scannerResultsContainer: document.getElementById('ai-scanner-results-container'),
                foodScannerStatus: document.getElementById('ai-scanner-status'),

                confirmModal: document.getElementById('confirm-modal'), confirmModalTitle: document.getElementById('confirm-modal-title'), confirmModalText: document.getElementById('confirm-modal-text'), confirmModalCancelBtn: document.getElementById('confirm-modal-cancel-btn'), confirmModalConfirmBtn: document.getElementById('confirm-modal-confirm-btn'), alertModal: document.getElementById('alert-modal'), alertModalTitle: document.getElementById('alert-modal-title'), alertModalText: document.getElementById('alert-modal-text'), alertModalOkBtn: document.getElementById('alert-modal-ok-btn'),

                aiMacroSwapBtn: document.getElementById('ai-macro-swap-btn'),

                savedItemsListDiv: document.getElementById('saved-items-list'), promptModal: document.getElementById('prompt-modal'), promptModalTitle: document.getElementById('prompt-modal-title'), promptModalText: document.getElementById('prompt-modal-text'), promptModalInput: document.getElementById('prompt-modal-input'), promptModalCancelBtn: document.getElementById('prompt-modal-cancel-btn'), promptModalOkBtn: document.getElementById('prompt-modal-ok-btn'), editFavoriteModal: document.getElementById('edit-favorite-modal'), closeEditFavoriteModalBtn: document.getElementById('close-edit-favorite-modal-btn'), editFavoriteForm: document.getElementById('edit-favorite-form'), dailySummaryCard: document.getElementById('daily-summary-card'), dayViewTitleSpan: document.getElementById('day-view-title-span'), dayViewDateSpan: document.getElementById('day-view-date-span'), aiDailyReportBtn: document.getElementById('ai-daily-report-btn'),
                aiReportModal: document.getElementById('ai-report-modal'), aiReportModalText: document.getElementById('ai-report-modal-text'), closeAiReportModalBtn: document.getElementById('close-ai-report-modal-btn'), aiReportModalOkBtn: document.getElementById('ai-report-modal-ok-btn'),
                addWaterBtn: document.getElementById('add-water-btn'),
                waterFill: document.getElementById('water-fill'), // NEW: Water fill UI
                waterSwipeBgLeft: document.getElementById('water-swipe-bg-left'), // NEW
                waterSwipeBgRight: document.getElementById('water-swipe-bg-right'), // NEW
                waterSwipeContent: document.getElementById('water-swipe-content'), // NEW

                openNutritionistChatBtn: document.getElementById('open-nutritionist-chat-btn'), aiNutritionistModal: document.getElementById('ai-nutritionist-modal'), closeAiNutritionistModalBtn: document.getElementById('close-ai-nutritionist-modal-btn'), aiChatHistory: document.getElementById('ai-chat-history'), aiChatInput: document.getElementById('ai-chat-input'), aiChatSendBtn: document.getElementById('ai-chat-send-btn'),

                foodScannerInitialOptions: document.getElementById('ai-scanner-initial-options'),
                liveCameraContainer: document.getElementById('ai-live-camera-container'),
                startFoodCameraBtn: document.getElementById('start-ai-camera-btn'),
                stopFoodCameraBtn: document.getElementById('stop-ai-camera-btn'),
                captureFoodPhotoBtn: document.getElementById('capture-ai-photo-btn'),
                foodCameraVideo: document.getElementById('ai-camera-video'),
                foodCameraCanvas: document.getElementById('ai-camera-canvas'),

                aiMealSuggesterBtn: document.getElementById('ai-meal-suggester-btn'),
                aiSuggesterModal: document.getElementById('ai-suggester-modal'),
                closeAiSuggesterModalBtn: document.getElementById('close-ai-suggester-modal-btn'),
                aiIngredientsInput: document.getElementById('ai-ingredients-input'),
                aiSuggestionBtn: document.getElementById('ai-suggestion-btn'),
                aiSuggestionsOutput: document.getElementById('ai-suggestions-output'),
                undoToast: document.getElementById('undo-toast'),
                undoToastBtn: document.getElementById('undo-toast-btn'),
                undoToastText: document.getElementById('undo-toast-text'),
                foodScannerCarouselWrapper: document.getElementById('ai-scanner-carousel-wrapper'),
                foodScannerPrev: document.getElementById('ai-scanner-prev'),
                foodScannerNext: document.getElementById('ai-scanner-next'),

                scanCombinedBtn: document.getElementById('scan-combined-btn'),

                aiMacroSwapModal: document.getElementById('ai-macro-swap-modal'),
                closeAiMacroSwapModalBtn: document.getElementById('close-ai-macro-swap-modal-btn'),
                aiMacroSwapOutput: document.getElementById('ai-macro-swap-output'),
                aiSwapFoodName: document.getElementById('ai-swap-food-name'),

                // NEW: Compound Food Modal UI
                compoundFoodModal: document.getElementById('compound-food-modal'),
                closeCompoundFoodModalBtn: document.getElementById('close-compound-food-modal-btn'),
                openCompoundFoodModalBtn: document.getElementById('open-compound-food-modal-btn'), // My new button
                addIngredientBtn: document.getElementById('add-ingredient-btn'),
                ingredientListContainer: document.getElementById('ingredient-list-container'),
                compoundFoodForm: document.getElementById('compound-food-form'),
                ingredientTemplate: document.getElementById('ingredient-row-template'),
                recipeNameInput: document.getElementById('recipe-name-input'),
                recipeCarouselPrev: document.getElementById('recipe-prev-ingredient'),
                recipeCarouselNext: document.getElementById('recipe-next-ingredient')
            };

            // --- CHART.JS SETUP ---
            const macroCtx = document.getElementById('macro-chart').getContext('2d');
            let macroChart = new Chart(macroCtx, { type: 'doughnut', data: { labels: ['Protein', 'Carbs', 'Fat'], datasets: [{ data: [1, 1, 1], backgroundColor: ['#3b82f6', '#10b981', '#ef4444'], borderWidth: 0, hoverOffset: 4 }] }, options: { responsive: true, maintainAspectRatio: false, cutout: '70%', plugins: { legend: { display: false } } } });

            // --- RENDER & DATA FLOW FUNCTIONS ---
            function updateSummary() {
                const dayLog = getDayLog(viewDate);
                const currentDayLogEntries = dayLog.entries;

                const totals = currentDayLogEntries.reduce((acc, item) => { acc.calories += item.calories || 0; acc.protein += item.protein || 0; acc.carbs += item.carbs || 0; acc.fat += item.fat || 0; acc.sugar += item.sugar || 0; acc.sodium += item.sodium || 0; acc.potassium += item.potassium || 0; return acc; }, { calories: 0, protein: 0, carbs: 0, fat: 0, sugar: 0, sodium: 0, potassium: 0 });

                document.getElementById('current-calories').textContent = totals.calories.toFixed(0); document.getElementById('goal-calories').textContent = goals.calories;
                document.getElementById('current-protein').textContent = totals.protein.toFixed(1); document.getElementById('goal-protein').textContent = goals.protein;
                document.getElementById('current-carbs').textContent = totals.carbs.toFixed(1); document.getElementById('goal-carbs').textContent = goals.carbs;
                document.getElementById('current-fat').textContent = totals.fat.toFixed(1); document.getElementById('goal-fat').textContent = goals.fat;
                document.getElementById('current-sugar').textContent = totals.sugar.toFixed(1); document.getElementById('goal-sugar').textContent = goals.sugar;
                document.getElementById('current-sodium').textContent = totals.sodium.toFixed(0); document.getElementById('goal-sodium').textContent = goals.sodium;
                document.getElementById('current-potassium').textContent = totals.potassium.toFixed(0); document.getElementById('goal-potassium').textContent = goals.potassium;
                document.getElementById('current-water').textContent = dayLog.water; document.getElementById('goal-water').textContent = goals.water;

                // Update water fill
                const waterPercent = Math.min(100, (dayLog.water / (goals.water || 1)) * 100);
                if (ui.waterFill) {
                    ui.waterFill.style.height = `${waterPercent}%`;
                }

                const macroSum = totals.protein + totals.carbs + totals.fat;
                macroChart.data.datasets[0].data = macroSum > 0 ? [totals.protein, totals.carbs, totals.fat] : [1, 1, 1];
                macroChart.update();
            }

            function renderDailyLog() {
                const currentDayLogEntries = getCurrentDayLogEntries();
                if (currentDayLogEntries.length === 0) { ui.dailyLogContentDiv.innerHTML = '<p class="text-gray-500">No food logged yet.</p>'; return; }
                const isFavorite = (itemName) => favoriteFoods.some(fav => fav.name.toLowerCase() === itemName.toLowerCase()) || savedRecipes.some(rec => rec.name.toLowerCase() === itemName.toLowerCase());
                 ui.dailyLogContentDiv.innerHTML = currentDayLogEntries.map((item, index) => `
                    <div class="swipe-item rounded-lg" data-index="${index}" data-type="log" data-name="${item.name}">
                        <div class="swipe-actions">
                            <div class="swipe-action-container left"><div class="action delete"><i data-lucide="trash-2" class="pointer-events-none"></i><span class="ml-2 pointer-events-none">Delete</span></div></div>
                            <div class="swipe-action-container right"><div class="action edit"><span class="mr-2 pointer-events-none">Edit</span><i data-lucide="pencil" class="pointer-events-none"></i></div></div>
                        </div>
                        <div class="swipe-content p-3 rounded-lg border border-transparent hover:border-gray-700"> <!-- Added border for hover -->
                            <div class="flex justify-between items-center">
                                <div class="flex items-center gap-3">
                                    ${isFavorite(item.name) ? '<i data-lucide="star" class="w-4 h-4 text-yellow-400 fill-yellow-400 flex-shrink-0"></i>' : '<div class="w-4 h-4 flex-shrink-0"></div>'}
                                    <div>
                                        <p class="font-medium">${item.servings}x ${item.name} ${item.grams > 0 ? `(${item.grams.toFixed(0)}g)` : ''}</p>
                                        <p class="text-sm text-gray-400">${item.calories?.toFixed(0) || 0}kcal | ${item.protein?.toFixed(1) || 0}p | ${item.carbs?.toFixed(1) || 0}c | ${item.fat?.toFixed(1) || 0}f</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `).join('');
                lucide.createIcons();
            }

            function renderSavedItemsList() {
                const combinedList = [
                    ...savedRecipes.map((item, index) => ({...item, type: 'recipe', originalIndex: index})),
                    ...favoriteFoods.map((item, index) => ({...item, type: 'food', originalIndex: index}))
                ].sort((a,b) => a.name.localeCompare(b.name));

                if (combinedList.length === 0) {
                    ui.savedItemsListDiv.innerHTML = '<p class="text-gray-500 text-center">No saved items yet.</p>';
                    return;
                }
                const isFavorite = (itemName) => favoriteFoods.some(fav => fav.name.toLowerCase() === itemName.toLowerCase()) || savedRecipes.some(rec => rec.name.toLowerCase() === itemName.toLowerCase());

                ui.savedItemsListDiv.innerHTML = combinedList.map(item => `
                    <div class="swipe-item rounded-lg" data-name="${item.name}" data-type="${item.type}" data-index="${item.originalIndex}">
                         <div class="swipe-actions">
                            <div class="swipe-action-container left"><div class="action delete"><i data-lucide="trash-2" class="pointer-events-none"></i><span class="ml-2 pointer-events-none">Delete</span></div></div>
                            <div class="swipe-action-container right"><div class="action edit"><span class="mr-2 pointer-events-none">Edit</span><i data-lucide="pencil" class="pointer-events-none"></i></div></div>
                        </div>
                        <div class="swipe-content p-3 rounded-lg border border-transparent hover:border-gray-700"> <!-- Added border for hover -->
                            <div class="flex justify-between items-center">
                                <div class="flex items-center gap-3">
                                   ${isFavorite(item.name) ? '<i data-lucide="star" class="w-4 h-4 text-yellow-400 fill-yellow-400 flex-shrink-0"></i>' : '<div class="w-4 h-4 flex-shrink-0"></div>'}
                                   <p class="font-medium">${item.name}</p>
                                   ${item.type === 'recipe' ? '<span class="text-xs bg-blue-500 text-white rounded-full px-2 py-0.4">Recipe</span>' : ''}
                                </div>
                                <button class="log-item-btn btn btn-secondary !p-2" title="Log Item"><i data-lucide="plus" class="w-4 h-4 pointer-events-none"></i></button>
                            </div>
                        </div>
                    </div>`).join('');
                lucide.createIcons();
            }


            function fullRender() {
                updateSummary();
                renderDailyLog();
                renderSavedItemsList();
                lucide.createIcons();
            }

            async function getDailyLogAIReport() {
                const btn = ui.aiDailyReportBtn;
                if (btn.disabled) return;

                const icon = btn.querySelector('.btn-text');
                const loader = btn.querySelector('.loader');

                if (icon) icon.style.display = 'none';
                if (loader) loader.classList.remove('hidden');
                btn.disabled = true;

                const dateKey = dateToKey(viewDate);
                const dayLog = getDayLog(viewDate);
                const currentLog = dayLog.entries;

                if (currentLog.length === 0) {
                    showCustomAlert('No Data', `There is no food logged for ${dateKey}.`);
                    if (loader) loader.classList.add('hidden');
                    if (icon) icon.style.display = 'inline-block';
                    btn.disabled = false;
                    return;
                }

                const totals = currentLog.reduce((acc, item) => { acc.calories += item.calories || 0; acc.protein += item.protein || 0; acc.carbs += item.carbs || 0; acc.fat += item.fat || 0; acc.sugar += item.sugar || 0; acc.sodium += item.sodium || 0; acc.potassium += item.potassium || 0; return acc; }, { calories: 0, protein: 0, carbs: 0, fat: 0, sugar: 0, sodium: 0, potassium: 0 });
                const goalData = goals;

                ui.aiReportModalText.textContent = 'Generating personalized report...';
                ui.aiReportModalText.classList.remove('text-red-400');
                showModal(ui.aiReportModal);

                const systemPrompt = `You are a friendly but expert nutrition coach. Provide a brief, actionable analysis of the user's daily food log. 1. Analyze the logged data against the goals. 2. Evaluate macro distribution (Protein, Carbs, Fat) and key micronutrients (Sodium/Potassium/Sugar). 3. Provide a concise summary (1-2 sentences). 4. Offer one specific, actionable tip for improvement/maintenance based on the biggest deviation or goal. Keep the report readable, using markdown bold for key stats, and keep the total response under 100 words.`;
                const userQuery = `Analyze the following log data for ${dateKey}: --- Logged Data --- Total Calories: ${totals.calories.toFixed(0)} kcal, Protein: ${totals.protein.toFixed(1)} g, Carbs: ${totals.carbs.toFixed(1)} g, Fat: ${totals.fat.toFixed(1)} g, Sugar: ${totals.sugar.toFixed(1)} g, Sodium: ${totals.sodium.toFixed(0)} mg, Potassium: ${totals.potassium.toFixed(0)} mg. Water: ${dayLog.water} ml. --- Daily Goals --- Calorie Goal: ${goalData.calories} kcal, Protein Goal: ${goalData.protein} g, Carb Goal: ${goalData.carbs} g, Fat Goal: ${goalData.fat} g, Sugar Limit: ${goalData.sugar} g, Sodium Limit: ${goalData.sodium} mg, Potassium Target: ${goalData.potassium} mg, Water Target: ${goalData.water} ml.`;

                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                const payload = {
                     contents: [{ parts: [{ text: userQuery }] }],
                     systemInstruction: { parts: [{ text: systemPrompt }] }
                };

                try {
                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");
                    let text = result.candidates[0].content.parts[0].text;
                    ui.aiReportModalText.innerHTML = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>');
                } catch (error) {
                    console.error("AI Report Error:", error);
                    hideModal(ui.aiReportModal);
                    showCustomAlert("AI Error", `Sorry, the AI coach couldn't generate a report. ${error.message}`);
                } finally {
                    btn.disabled = false;
                    if (loader) loader.classList.add('hidden');
                    if (icon) icon.style.display = 'inline-block';
                }
            }


            function updateDayView(date) {
                viewDate = date; const today = new Date(); today.setHours(0, 0, 0, 0);
                const dateKey = dateToKey(date), isToday = dateKey === dateToKey(today);
                ui.dayViewTitleSpan.textContent = isToday ? 'Today' : date.toLocaleDateString(undefined, { weekday: 'long' });
                ui.dayViewDateSpan.textContent = date.toLocaleDateString(undefined, { month: 'long', day: 'numeric' });
                fullRender();
            }

            async function getMacrosFromAI(foodName, brand) {
                let prompt = `Provide nutritional information for 100g of "${foodName}"`;
                if (brand) prompt += ` from the brand "${brand}"`;
                prompt += `. Respond with only a valid JSON object containing all fields for 100 grams: "calories", "protein", "carbs", "fat", "sugar", "sodium", "potassium". Also include a "servingGrams": 100 field. If it's a food that is hard to quantify, like "salad", provide a reasonable estimate for 100g.`;

                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                const payload = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { responseMimeType: "application/json" } };
                 try {
                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");
                    return JSON.parse(result.candidates[0].content.parts[0].text);
                 } catch (error) {
                     console.error("getMacrosFromAI Error:", error);
                     throw error;
                 }
            }

            async function getPartialMacrosFromAI(foodName, brand, knownMacros) {
                let knownMacrosString = Object.entries(knownMacros).map(([key, value]) => `${key}: ${value}`).join(', ');
                let prompt = `For a standard single serving of "${foodName}"`;
                if (brand) prompt += ` from the brand "${brand}"`;
                prompt += `, we know it has the following values: ${knownMacrosString}. Based on this, estimate the *missing* nutritional values. Respond with only a valid JSON object containing a *complete* set of fields for ONE standard serving: "servingGrams", "calories", "protein", "carbs", "fat", "sugar", "sodium", "potassium". Use the provided values as facts and fill in the rest with reasonable estimates.`;

                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                const payload = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { responseMimeType: "application/json" } };

                try {
                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");
                    return JSON.parse(result.candidates[0].content.parts[0].text);
                } catch (error) {
                    console.error("getPartialMacrosFromAI Error:", error);
                    throw error;
                }
            }
            function toggleFavorite(itemName) {
                if (savedRecipes.some(r => r.name.toLowerCase() === itemName.toLowerCase())) {
                    showCustomAlert("Action Not Allowed", "Recipes are automatically favorited and cannot be unfavorited.");
                    return;
                }
                const favIndex = favoriteFoods.findIndex(fav => fav.name.toLowerCase() === itemName.toLowerCase());
                if (favIndex > -1) {
                    favoriteFoods.splice(favIndex, 1);
                } else {
                     const logItem = getCurrentDayLogEntries().find(item => item.name.toLowerCase() === itemName.toLowerCase()) || savedRecipes.find(item => item.name.toLowerCase() === itemName.toLowerCase());
                     if (!logItem) {
                         showCustomAlert("Error", "Could not find item to favorite.");
                         return;
                     }
                    const totalGrams = logItem.grams || 0;
                    if (totalGrams <= 0) {
                         showCustomAlert("Cannot Favorite", "Cannot favorite an item with 0 grams to calculate base macros.");
                         return;
                    }
                    const ratio = 100 / (totalGrams / (logItem.servings || 1));
                    favoriteFoods.push({
                        name: logItem.name,
                        calories: (logItem.calories / (logItem.servings || 1)) * ratio,
                        protein: (logItem.protein / (logItem.servings || 1)) * ratio,
                        carbs: (logItem.carbs / (logItem.servings || 1)) * ratio,
                        fat: (logItem.fat / (logItem.servings || 1)) * ratio,
                        sugar: ((logItem.sugar || 0) / (logItem.servings || 1)) * ratio,
                        sodium: ((logItem.sodium || 0) / (logItem.servings || 1)) * ratio,
                        potassium: ((logItem.potassium || 0) / (logItem.servings || 1)) * ratio,
                     });
                }
                saveData();
                fullRender();
            }

            function showUndo(type, data) {
                clearTimeout(undoTimeout);
                lastAction = { type, data };
                let text;
                if (type === 'delete') {
                    text = `Deleted "${data.item.name}"`;
                } else if (type === 'edit') {
                    text = `Edited "${data.originalItem.name}"`;
                } else if (type === 'water') {
                    text = `Water updated to ${data.newWater}ml`;
                }

                ui.undoToastText.textContent = text;
                ui.undoToast.classList.remove('translate-y-24', 'opacity-0');

                undoTimeout = setTimeout(() => {
                    hideUndo();
                }, 5000);
            }

            function hideUndo() {
                lastAction = null;
                ui.undoToast.classList.add('translate-y-24', 'opacity-0');
            }

            function setupCarousel(containerId, prevBtnId, nextBtnId) {
                const container = document.getElementById(containerId);
                const prevBtn = document.getElementById(prevBtnId);
                const nextBtn = document.getElementById(nextBtnId);
                const wrapper = container ? container.closest('.carousel-wrapper') : null;

                if (!container || !prevBtn || !nextBtn || !wrapper) {
                     return;
                }

                 prevBtn.style.display = 'none';
                 nextBtn.style.display = 'none';

                const scrollAmount = () => {
                    const firstItem = container.querySelector('.scroll-item');
                    return firstItem ? firstItem.offsetWidth + 16 : container.offsetWidth * 0.9;
                };

                prevBtn.onclick = () => {
                    container.scrollBy({ left: -scrollAmount(), behavior: 'smooth' });
                };

                nextBtn.onclick = () => {
                    container.scrollBy({ left: scrollAmount(), behavior: 'smooth' });
                };

                // Add scroll event listener to show/hide buttons
                container.addEventListener('scroll', () => {
                    const scrollLeft = container.scrollLeft;
                    const scrollWidth = container.scrollWidth;
                    const clientWidth = container.clientWidth;

                    prevBtn.style.display = scrollLeft > 10 ? 'flex' : 'none';
                    nextBtn.style.display = scrollLeft < scrollWidth - clientWidth - 10 ? 'flex' : 'none';
                });
            }

            // --- NEW: Compound Food Modal Functions ---

            /**
             * Creates a new ingredient row from the template and adds it to the list.
             */
            function addIngredientRow() {
                // Clone the template
                const newRowFragment = ui.ingredientTemplate.content.cloneNode(true);
                const newRow = newRowFragment.firstElementChild; // Get the actual <div>

                const ingredientNumber = ui.ingredientListContainer.querySelectorAll('.ingredient-row').length + 1;

                // Update the number
                newRow.querySelector('.ingredient-number').textContent = ingredientNumber;

                // --- Add unique IDs for accessibility (robust version) ---
                const uniqueIdSuffix = `_row_${ingredientNumber}`;
                const inputs = newRow.querySelectorAll('input[type="text"], input[type="number"]');

                inputs.forEach(input => {
                    // Find the associated label
                    const label = input.previousElementSibling;
                    if (label && label.tagName === 'LABEL') {
                        // Get a clean ID from the input's class list
                        const idName = Array.from(input.classList).find(c => c.startsWith('ingredient-'));
                        if (idName) {
                            const newId = `${idName}${uniqueIdSuffix}`; // e.g., "ingredient-name_row_2"
                            input.id = newId;
                            label.setAttribute('for', newId);
                        }
                    }
                });
                // --- End accessibility linking ---

                // Add the new row to the DOM
                ui.ingredientListContainer.appendChild(newRow);

                // Create icons *only* for the new row (much faster)
                lucide.createIcons({
                    nodes: [newRow]
                });

                // Renumber all items
                updateIngredientNumbers();

                // Scroll to the new ingredient (useful if list is long)
                newRow.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

                // Disable the "Add" button since this new row is empty
                validateLastRow();
            }

            /**
             * Checks if the last ingredient row is valid (name filled).
             * Enables or disables the "Add Ingredient" button based on the result.
             */
            function validateLastRow() {
                // NEW: Check for recipe name first
                const hasRecipeName = ui.recipeNameInput.value.trim() !== '';
                if (!hasRecipeName) {
                    ui.addIngredientBtn.disabled = true;
                    return false;
                }

                const allRows = ui.ingredientListContainer.querySelectorAll('.ingredient-row');
                if (allRows.length === 0) {
                    ui.addIngredientBtn.disabled = false; // No rows, allow adding one
                    ui.addIngredientBtn.removeAttribute('title');
                    return true;
                }

                const lastRow = allRows[allRows.length - 1];
                const name = lastRow.querySelector('.ingredient-name').value.trim();

                const isValid = name !== '';

                ui.addIngredientBtn.disabled = !isValid;
                if (isValid) {
                    ui.addIngredientBtn.removeAttribute('title');
                } else {
                    ui.addIngredientBtn.setAttribute('title', 'Please fill out the ingredient name first.');
                }

                return isValid;
            }

            /**
             * Updates the number (#1, #2, etc.) on all ingredient rows.
             */
            function updateIngredientNumbers() {
                const rows = ui.ingredientListContainer.querySelectorAll('.ingredient-row');
                rows.forEach((row, index) => {
                    const numberSpan = row.querySelector('.ingredient-number');
                    if (numberSpan) {
                        numberSpan.textContent = index + 1;
                    }
                });
            }

            /**
             * Calculates and displays the total macros from all ingredient rows.
             */
            function updateRecipeTotals() {
                const rows = ui.ingredientListContainer.querySelectorAll('.ingredient-row');
                let total = {
                    calories: 0, protein: 0, carbs: 0, fat: 0,
                    grams: 0, sugar: 0, sodium: 0, potassium: 0
                };

                rows.forEach(row => {
                    const getVal = (selector) => parseFloat(row.querySelector(selector).value) || 0;
                    total.grams += getVal('.ingredient-grams');
                    total.calories += getVal('.ingredient-calories');
                    total.protein += getVal('.ingredient-protein');
                    total.carbs += getVal('.ingredient-carbs');
                    total.fat += getVal('.ingredient-fat');
                    total.sugar += getVal('.ingredient-sugar');
                    total.sodium += getVal('.ingredient-sodium');
                    total.potassium += getVal('.ingredient-potassium');
                });

                // Helper to update text, formatting to 1 decimal place if not an integer
                const setTotal = (id, value, maxDecimals = 1) => {
                    const el = document.getElementById(id);
                    if (el) {
                         el.textContent = parseFloat(value.toFixed(maxDecimals));
                    }
                };

                // Get the span elements for text content
                const setTotalSpan = (id, value, maxDecimals = 1) => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.textContent = parseFloat(value.toFixed(maxDecimals));
                    }
                };

                // Use the correct function for each element
                setTotal('recipe-total-calories', total.calories);
                setTotalSpan('recipe-total-protein', total.protein);
                setTotalSpan('recipe-total-carbs', total.carbs);
                setTotalSpan('recipe-total-fat', total.fat);
                setTotal('recipe-total-grams', total.grams);
                setTotalSpan('recipe-total-sugar', total.sugar);
                setTotalSpan('recipe-total-sodium', total.sodium, 0); // No decimals for sodium/potassium
                setTotalSpan('recipe-total-potassium', total.potassium, 0);
            }

            async function fetchIngredientMacros(recipeName, ingredientData, signal) {
                const apiKey = ""; // Leave empty
                // FIX 2: Use the new, faster model
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

                let userQuery = `Recipe context: "${recipeName}". Ingredient: "${ingredientData.quantity || 1} ${ingredientData.name}".`;
                const providedInfo = [];
                if (ingredientData.grams) providedInfo.push(`Amount: ${ingredientData.grams}g`);
                if (ingredientData.calories) providedInfo.push(`Calories: ${ingredientData.calories}kcal`);
                if (ingredientData.protein) providedInfo.push(`Protein: ${ingredientData.protein}g`);
                if (ingredientData.carbs) providedInfo.push(`Carbs: ${ingredientData.carbs}g`);
                if (ingredientData.fat) providedInfo.push(`Fat: ${ingredientData.fat}g`);

                if (providedInfo.length > 0) {
                    userQuery += ` Provided info: ${providedInfo.join(', ')}.`;
                }

                if (ingredientData.grams) {
                     userQuery += " Please find all nutritional data for the specified amount.";
                } else {
                    userQuery += " Amount not specified, so please estimate a typical serving size in grams and find all nutritional data for that estimated amount.";
                }

                const systemPrompt = "You are a nutritional database. Given a recipe context, an ingredient name, and (optionally) some existing nutritional data (like grams or protein), find all missing nutritional information and return the complete set. If grams are not specified, estimate a typical serving size in grams. Respond only with the valid JSON object described in the schema. Do not include 'g' or 'mg' units, just the numbers. For sugar, sodium, and potassium, if data is unavailable, return 0.";

                const payload = {
                    contents: [{ parts: [{ text: userQuery }] }],
                    // FIX 2: Added search grounding to improve food lookup reliability
                    tools: [{ "google_search": {} }],
                    systemInstruction: {
                        parts: [{ text: systemPrompt }]
                    },
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "grams": { "type": "NUMBER", "description": "The weight in grams. Use the provided amount or estimate if not provided." },
                                "calories": { "type": "NUMBER", "description": "Total kilocalories." },
                                "protein": { "type": "NUMBER", "description": "Grams of protein." },
                                "carbs": { "type": "NUMBER", "description": "Grams of carbohydrates." },
                                "fat": { "type": "NUMBER", "description": "Grams of fat." },
                                "sugar": { "type": "NUMBER", "description": "Grams of sugar. Return 0 if unknown." },
                                "sodium": { "type": "NUMBER", "description": "Milligrams of sodium. Return 0 if unknown." },
                                "potassium": { "type": "NUMBER", "description": "Milligrams of potassium. Return 0 if unknown." }
                            },
                            required: ["grams", "calories", "protein", "carbs", "fat", "sugar", "sodium", "potassium"]
                        }
                    }
                };

                // Add exponential backoff for retries
                let response;
                let retries = 3;
                let delay = 1000;
                for (let i = 0; i < retries; i++) {
                    try {
                        response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload),
                            signal: signal // NEW: Pass the abort signal
                        });
                        if (response.ok) {
                            break; // Success
                        }
                    } catch (error) {
                        // Network error
                    }
                    if (i < retries - 1) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2;
                    }
                }

                if (!response || !response.ok) {
                    throw new Error("Failed to fetch data from AI after retries.");
                }

                const result = await response.json();
                const candidate = result.candidates?.[0];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    try {
                        const jsonText = candidate.content.parts[0].text;
                        const parsedJson = JSON.parse(jsonText);
                        return parsedJson; // This is the structured data
                    } catch (e) {
                        console.error("Failed to parse JSON response:", e);
                        throw new Error("AI returned invalid JSON.");
                    }
                } else {
                    console.error("Invalid AI response structure:", result);
                    throw new Error("AI returned no valid content.");
                }
            }

            // --- END NEW Compound Food Modal Functions ---


            // --- EVENT LISTENERS ---
            ui.addFoodBtn.addEventListener('click', async () => {
                ui.addFoodError.textContent = '';
                const btn = ui.addFoodBtn;
                const btnText = btn.querySelector('.btn-text');
                const loader = btn.querySelector('.loader');

                const foodName = capitalizeWords(ui.foodNameInput.value.trim());
                const servings = parseFloat(ui.foodServingsInput.value);

                if (!foodName || isNaN(servings) || servings <= 0) {
                    ui.addFoodError.textContent = "Please enter a valid food name and serving amount.";
                    return;
                }

                let singleServingMacros = {};
                let manualMacros = {};
                let manualMacroCount = 0;
                let hasError = false;
                const macroKeys = ['calories', 'protein', 'carbs', 'fat', 'sugar', 'sodium', 'potassium'];

                macroKeys.forEach(m => {
                    const input = document.getElementById(`food-${m}-input`);
                    const valStr = input.value.trim();
                    if (valStr !== '') {
                        const val = parseFloat(valStr);
                        if (!isNaN(val) && val < 0) {
                            ui.addFoodError.textContent = "Macro values cannot be negative.";
                            input.classList.add('!border-red-500');
                            hasError = true;
                        } else if (!isNaN(val)) {
                            input.classList.remove('!border-red-500');
                            singleServingMacros[m] = val;
                            manualMacros[m] = val;
                            manualMacroCount++;
                        }
                    } else {
                        singleServingMacros[m] = 0;
                    }
                });

                if (hasError) return;

                let servingGrams = parseFloat(ui.foodGramsInput.value) || 0;

                if (editingFoodLogIndex === null) {
                    if (manualMacroCount > 0 && manualMacroCount < macroKeys.length) {
                        btn.disabled = true; btnText.style.display = 'none'; loader.classList.remove('hidden');
                        try {
                            const brand = ui.foodBrandInput.value.trim();
                            const data = await getPartialMacrosFromAI(foodName, brand, manualMacros);
                            servingGrams = data.servingGrams || servingGrams || 0;
                            singleServingMacros = {
                                calories: manualMacros.calories ?? (parseFloat(data.calories) || 0),
                                protein: manualMacros.protein ?? (parseFloat(data.protein) || 0),
                                carbs: manualMacros.carbs ?? (parseFloat(data.carbs) || 0),
                                fat: manualMacros.fat ?? (parseFloat(data.fat) || 0),
                                sugar: manualMacros.sugar ?? (parseFloat(data.sugar) || 0),
                                sodium: manualMacros.sodium ?? (parseFloat(data.sodium) || 0),
                                potassium: manualMacros.potassium ?? (parseFloat(data.potassium) || 0),
                            };
                            document.getElementById('food-calories-input').value = singleServingMacros.calories.toFixed(0);
                            document.getElementById('food-protein-input').value = singleServingMacros.protein.toFixed(1);
                            document.getElementById('food-carbs-input').value = singleServingMacros.carbs.toFixed(1);
                            document.getElementById('food-fat-input').value = singleServingMacros.fat.toFixed(1);
                            document.getElementById('food-sugar-input').value = singleServingMacros.sugar.toFixed(1);
                            document.getElementById('food-sodium-input').value = singleServingMacros.sodium.toFixed(0);
                            document.getElementById('food-potassium-input').value = singleServingMacros.potassium.toFixed(0);
                            if (servingGrams > 0) ui.foodGramsInput.value = servingGrams.toFixed(0);

                        } catch (error) {
                            console.error("AI Partial Macros Error:", error);
                            ui.addFoodError.textContent = `Could not estimate missing macros. ${error.message}`;
                        } finally {
                            btn.disabled = false; btnText.style.display = 'inline-block'; loader.classList.add('hidden');
                        }
                    } else if (manualMacroCount === 0) {
                        btn.disabled = true; btnText.style.display = 'none'; loader.classList.remove('hidden');
                        try {
                            const brand = ui.foodBrandInput.value.trim();
                            const data = await getMacrosFromAI(foodName, brand);
                            servingGrams = 100;
                            singleServingMacros = {
                                calories: parseFloat(data.calories) || 0,
                                protein: parseFloat(data.protein) || 0,
                                carbs: parseFloat(data.carbs) || 0,
                                fat: parseFloat(data.fat) || 0,
                                sugar: parseFloat(data.sugar) || 0,
                                sodium: parseFloat(data.sodium) || 0,
                                potassium: parseFloat(data.potassium) || 0
                            };
                            const userGrams = parseFloat(ui.foodGramsInput.value);
                            if (!isNaN(userGrams) && userGrams > 0) {
                                const ratio = userGrams / 100.0;
                                servingGrams = userGrams;
                                for (const key in singleServingMacros) {
                                    singleServingMacros[key] *= ratio;
                                }
                                document.getElementById('food-calories-input').value = singleServingMacros.calories.toFixed(0);
                                document.getElementById('food-protein-input').value = singleServingMacros.protein.toFixed(1);
                                document.getElementById('food-carbs-input').value = singleServingMacros.carbs.toFixed(1);
                                document.getElementById('food-fat-input').value = singleServingMacros.fat.toFixed(1);
                                document.getElementById('food-sugar-input').value = singleServingMacros.sugar.toFixed(1);
                                document.getElementById('food-sodium-input').value = singleServingMacros.sodium.toFixed(0);
                                document.getElementById('food-potassium-input').value = singleServingMacros.potassium.toFixed(0);

                            } else {
                                ui.foodGramsInput.value = servingGrams.toFixed(0);
                                document.getElementById('food-calories-input').value = singleServingMacros.calories.toFixed(0);
                                document.getElementById('food-protein-input').value = singleServingMacros.protein.toFixed(1);
                                document.getElementById('food-carbs-input').value = singleServingMacros.carbs.toFixed(1);
                                document.getElementById('food-fat-input').value = singleServingMacros.fat.toFixed(1);
                                document.getElementById('food-sugar-input').value = singleServingMacros.sugar.toFixed(1);
                                document.getElementById('food-sodium-input').value = singleServingMacros.sodium.toFixed(0);
                                document.getElementById('food-potassium-input').value = singleServingMacros.potassium.toFixed(0);
                            }

                        } catch (error) {
                            console.error("AI Get Macros Error:", error);
                             ui.addFoodError.textContent = `Could not fetch nutrition data. ${error.message}`;
                        } finally {
                            btn.disabled = false; btnText.style.display = 'inline-block'; loader.classList.add('hidden');
                        }
                    }
                }


                if (ui.addFoodError.textContent) return;

                const dayLog = getDayLog(viewDate);
                const totalMacros = {};
                macroKeys.forEach(m => {
                    totalMacros[m] = (singleServingMacros[m] || 0) * servings;
                });

                const foodItem = {
                    name: foodName,
                    brand: ui.foodBrandInput.value.trim(),
                    servings,
                    grams: servingGrams * servings,
                    ...totalMacros
                };

                if (editingFoodLogIndex !== null) {
                    const originalItem = { ...dayLog.entries[editingFoodLogIndex] };
                    dayLog.entries[editingFoodLogIndex] = foodItem;
                    showUndo('edit', { index: editingFoodLogIndex, originalItem: originalItem });
                    editingFoodLogIndex = null;
                } else {
                    dayLog.entries.unshift(foodItem);
                }

                ui.logMealForm.reset();
                ui.foodServingsInput.value = 1;
                saveData();
                updateDayView(viewDate);
            });

            // --- REMOVED Water Log Modal Logic ---

            // --- NEW: Water Update Function (Simplified) ---
            const updateWater = (amount, isSetTotal = false) => {
                const dayLog = getDayLog(viewDate);
                const originalWater = dayLog.water || 0;
                let newWater;

                if (isSetTotal) {
                    newWater = Math.max(0, amount);
                } else {
                    newWater = Math.max(0, originalWater + amount);
                    lastWaterLogAmount = amount; // Store the DELTA amount
                }

                if (newWater !== originalWater) {
                    dayLog.water = newWater;
                    saveData();
                    updateDayView(viewDate); // This updates the main summary and fill

                    // Show undo only for incremental changes (where lastWaterLogAmount was set)
                    if (!isSetTotal && lastWaterLogAmount !== 0) {
                         showUndo('water', { originalWater: originalWater, newWater: newWater });
                    }
                } else {
                    // If no change, reset lastWaterLogAmount to avoid incorrect undo
                    if (!isSetTotal) {
                        lastWaterLogAmount = 0;
                    }
                }
            };

            // --- NEW: Water Button Gesture Handling ---
            let waterPointerStart = { x: 0, y: 0 };
            let waterPointerDelta = { x: 0, y: 0 };
            let isWaterSwiping = false;
            let waterCurrentX = 0; // NEW: Track horizontal translation

            function onWaterPointerDown(e) {
                const coords = getPointerCoordinates(e);
                waterPointerStart.x = coords.x;
                waterPointerStart.y = coords.y;
                waterPointerDelta = { x: 0, y: 0 };
                isWaterSwiping = false;
                waterCurrentX = 0;
                ui.waterSwipeContent.classList.add('swiping');
                ui.waterSwipeContent.style.transform = '';

                document.addEventListener('mousemove', onWaterPointerMove);
                document.addEventListener('mouseup', onWaterPointerUp);
                document.addEventListener('touchmove', onWaterPointerMove, { passive: false });
                document.addEventListener('touchend', onWaterPointerUp);
            }

            function onWaterPointerMove(e) {
                const coords = getPointerCoordinates(e);
                waterPointerDelta.x = coords.x - waterPointerStart.x;
                waterPointerDelta.y = coords.y - waterPointerStart.y;

                if (!isWaterSwiping && (Math.abs(waterPointerDelta.x) > 10 || Math.abs(waterPointerDelta.y) > 10)) {
                    isWaterSwiping = true;
                }

                if (isWaterSwiping) {
                    // Prevent page scroll only if swiping vertically significantly
                    if (Math.abs(waterPointerDelta.y) > Math.abs(waterPointerDelta.x) && Math.abs(waterPointerDelta.y) > 10) {
                        if (e.cancelable) e.preventDefault();
                    }

                    const waterSwipeBgTop = document.getElementById('water-swipe-bg-top'); // Get new element

                    if (Math.abs(waterPointerDelta.y) > Math.abs(waterPointerDelta.x)) {
                        // --- VERTICAL SWIPE ---
                        waterCurrentX = 0;
                        ui.waterSwipeContent.style.transform = 'translateX(0px)';
                        ui.waterSwipeBgLeft.style.opacity = '0';
                        ui.waterSwipeBgRight.style.opacity = '0';

                        if (waterPointerDelta.y > 0) { // Swiping Down
                            waterSwipeBgTop.style.opacity = Math.min(1, waterPointerDelta.y / 80).toString();
                            waterSwipeBgTop.style.height = `${waterPointerDelta.y}px`;
                            ui.waterSwipeContent.style.transform = `translateY(${waterPointerDelta.y}px)`; // Move content down
                        } else { // Swiping Up
                            waterSwipeBgTop.style.opacity = '0';
                            waterSwipeBgTop.style.height = '0';
                            ui.waterSwipeContent.style.transform = `translateY(0px)`; // Reset
                        }

                    } else {
                        // --- HORIZONTAL SWIPE ---
                        waterSwipeBgTop.style.opacity = '0'; // Hide vertical bg
                        waterSwipeBgTop.style.height = '0';
                        ui.waterSwipeContent.style.transform = `translateY(0px)`; // Reset Y translate

                        waterCurrentX = waterPointerDelta.x;
                        ui.waterSwipeContent.style.transform = `translateX(${waterCurrentX}px)`;

                        if (waterCurrentX < 0) { // Swiping Left
                            ui.waterSwipeBgLeft.style.opacity = Math.min(1, Math.abs(waterCurrentX) / 80).toString();
                            ui.waterSwipeBgRight.style.opacity = '0';
                        } else { // Swiping Right
                            ui.waterSwipeBgRight.style.opacity = Math.min(1, waterCurrentX / 80).toString();
                            ui.waterSwipeBgLeft.style.opacity = '0';
                        }
                    }
                }
            }

            function onWaterPointerUp(e) {
                document.removeEventListener('mousemove', onWaterPointerMove);
                document.removeEventListener('mouseup', onWaterPointerUp);
                document.removeEventListener('touchmove', onWaterPointerMove);
                document.removeEventListener('touchend', onWaterPointerUp);

                // NEW: Add returning class
                ui.waterSwipeContent.classList.add('returning');
                ui.waterSwipeContent.classList.remove('swiping');

                const waterSwipeBgTop = document.getElementById('water-swipe-bg-top'); // Get new element
                // Hide swipe backgrounds (they will fade out)
                ui.waterSwipeBgLeft.style.opacity = '0';
                ui.waterSwipeBgRight.style.opacity = '0';
                waterSwipeBgTop.style.opacity = '0'; // Hide new bg
                waterSwipeBgTop.style.height = '0'; // Reset height

                const totalDistance = Math.sqrt(waterPointerDelta.x**2 + waterPointerDelta.y**2);
                const swipeThreshold = 30; // Min distance to count as swipe
                const horizontalSwipeThreshold = ui.waterSwipeContent.offsetWidth * 0.35; // Match food log

                if (!isWaterSwiping && totalDistance < 10) {
                    // --- TAP ---
                    const defaultSize = userProfile.waterServingSize || 250;
                    updateWater(defaultSize);
                    ui.waterSwipeContent.style.transform = 'translateX(0) translateY(0)'; // Ensure it's reset
                } else if (isWaterSwiping) {
                    if (Math.abs(waterPointerDelta.y) > Math.abs(waterPointerDelta.x)) {
                        // --- VERTICAL SWIPE ---
                        ui.waterSwipeContent.style.transform = 'translateX(0) translateY(0)'; // Snap back X and Y
                        if (waterPointerDelta.y < -swipeThreshold) {
                            // Swipe Up: Does nothing
                            // (This block is intentionally left empty)
                        } else if (waterPointerDelta.y > swipeThreshold) {
                             // Swipe Down: Edit daily water goal
                            showPromptModal("Set Water Goal", "Enter your new daily water goal (ml):", goals.water, (newGoalStr) => {
                                if (newGoalStr === null) return;
                                const newGoal = parseInt(newGoalStr);
                                if (!isNaN(newGoal) && newGoal >= 0) {
                                    goals.water = newGoal;
                                    saveData();
                                    updateDayView(viewDate); // This will re-render fill %
                                } else {
                                    showCustomAlert("Invalid Goal", "Please enter a non-negative number for your goal.");
                                }
                            });
                        }
                    } else {
                        // --- HORIZONTAL SWIPE ---
                        if (waterCurrentX < -horizontalSwipeThreshold) {
                            // Swipe Left: Edit glass volume
                            showPromptModal("Set Glass Size", "Enter your default water glass size (ml):", userProfile.waterServingSize || 250, (newSizeStr) => {
                                if (newSizeStr === null) return;
                                const newSize = parseInt(newSizeStr);
                                if (!isNaN(newSize) && newSize > 0) {
                                    userProfile.waterServingSize = newSize;
                                    saveData();
                                    showCustomAlert("Glass Size Updated", `Your default glass size is now ${newSize}ml.`);
                                } else {
                                    showCustomAlert("Invalid Size", "Please enter a positive number for your glass size.");
                                }
                            });
                            ui.waterSwipeContent.style.transform = 'translateX(0) translateY(0)'; // Snap back
                        } else if (waterCurrentX > horizontalSwipeThreshold) {
                            // Swipe Right: Remove 1 glass
                            const defaultSize = userProfile.waterServingSize || 250;
                            updateWater(-defaultSize);
                            ui.waterSwipeContent.style.transform = 'translateX(0) translateY(0)'; // Snap back
                        } else {
                            // --- NO THRESHOLD MET ---
                            ui.waterSwipeContent.style.transform = 'translateX(0) translateY(0)'; // Snap back
                        }
                    }
                } else {
                    // Not a swipe, not a tap. Just reset.
                    ui.waterSwipeContent.style.transform = 'translateX(0) translateY(0)';
                }

                // Failsafe cleanup
                setTimeout(() => {
                    if (ui.waterSwipeContent) { // Check if element still exists
                        ui.waterSwipeContent.classList.remove('returning');
                        ui.waterSwipeContent.style.transform = ''; // Remove style
                    }
                }, 300); // Match food log

                isWaterSwiping = false;
                waterPointerDelta = { x: 0, y: 0 };
                waterCurrentX = 0; // Reset
            }

            ui.addWaterBtn.addEventListener('mousedown', onWaterPointerDown);
            ui.addWaterBtn.addEventListener('touchstart', onWaterPointerDown, { passive: true });
            // --- END Water Button Gesture Handling ---

            ui.scanCombinedBtn.addEventListener('click', () => {
                activeRecipeScanBtn = null; // Ensure this is null when opening main scanner
                ui.scannerResultsContainer.innerHTML = '';
                ui.foodScannerStatus.textContent = '';
                ui.liveCameraContainer.classList.add('hidden');
                ui.foodScannerInitialOptions.classList.remove('hidden');
                ui.foodScannerCarouselWrapper.classList.add('hidden');
                showModal(ui.foodScannerModal);
            });

            ui.aiMacroSwapBtn.addEventListener('click', async () => {
                const btn = ui.aiMacroSwapBtn;
                const btnText = btn.querySelector('.btn-text');
                const loader = btn.querySelector('.loader');

                const foodName = capitalizeWords(ui.foodNameInput.value.trim());
                if (!foodName) {
                    showCustomAlert("No Food Entered", "Please enter a food name in the form first.");
                    return;
                }

                btn.disabled = true;
                btnText.style.display = 'none';
                loader.classList.remove('hidden');

                ui.aiSwapFoodName.textContent = foodName;
                showModal(ui.aiMacroSwapModal);
                ui.aiMacroSwapOutput.innerHTML = '<div class="loader mx-auto"></div>';

                try {
                    const swaps = await getAiMacroSwaps(foodName);

                    if (swaps && swaps.length > 0) {
                        ui.aiMacroSwapOutput.innerHTML = swaps.map(swap => `
                            <button type="button" class="btn btn-secondary w-full !justify-between !text-left swap-suggestion-btn" data-food-name="${swap.name}">
                                <div class="flex flex-col">
                                    <span class="font-semibold text-white">${swap.name}</span>
                                    <span class="text-xs text-gray-400 font-normal">${swap.reason}</span>
                                </div>
                                <i data-lucide="chevron-right" class="w-5 h-5 text-gray-400"></i>
                            </button>
                        `).join('');
                        lucide.createIcons();
                    } else {
                        ui.aiMacroSwapOutput.innerHTML = `<p class="text-gray-400 text-center">No swap suggestions found for "${foodName}".</p>`;
                    }

                } catch (error) {
                    console.error("AI Macro Swap Error:", error);
                    ui.aiMacroSwapOutput.innerHTML = `<p class="text-red-400">${error.message}</p>`;
                } finally {
                    btn.disabled = false;
                    btnText.style.display = 'inline-block';
                    loader.classList.add('hidden');
                }
            });

            async function getAiMacroSwaps(foodName) {
                const systemPrompt = `User is considering eating '${foodName}'. Their goal is ${userProfile.goal}. Suggest 3-5 healthier alternatives that fit a similar craving (e.g., salty, sweet, crunchy). For each, provide 'name' and 'reason' (why it's better, e.g., "Lower in fat", "Higher in protein"). Respond ONLY with a valid JSON array of objects: [{name: "Food 1", reason: "Lower in fat"}, {name: "Food 2", reason: "Higher in protein"}]`;

                const userQuery = `Suggest swaps for ${foodName}`;

                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                const payload = {
                     contents: [{ parts: [{ text: userQuery }] }],
                     // FIX 2: Added search grounding to improve food lookup reliability
                     tools: [{ "google_search": {} }],
                     systemInstruction: { parts: [{ text: systemPrompt }] },
                     generationConfig: { responseMimeType: "application/json" }
                };

                try {
                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");
                    return JSON.parse(result.candidates[0].content.parts[0].text);
                } catch (error) {
                    console.error("getAiMacroSwaps Error:", error);
                    throw error;
                }
            }

            ui.closeAiMacroSwapModalBtn.addEventListener('click', () => hideModal(ui.aiMacroSwapModal));

            ui.aiMacroSwapOutput.addEventListener('click', (e) => {
                const swapBtn = e.target.closest('.swap-suggestion-btn');
                if (swapBtn) {
                    const foodName = swapBtn.dataset.food-name;
                    if (foodName) {
                        ui.foodNameInput.value = foodName;
                        const macroInputs = ui.logMealForm.querySelectorAll('.macro-input');
                        macroInputs.forEach(input => input.value = '');
                        ui.foodGramsInput.value = '';
                        ui.foodBrandInput.value = '';
                        ui.foodServingsInput.value = 1;

                        hideModal(ui.aiMacroSwapModal);

                        ui.logMealForm.scrollIntoView({ behavior: 'smooth' });
                        ui.addFoodBtn.click();
                    }
                }
            });

            const handleEditLogItem = (index) => {
                 const item = getCurrentDayLogEntries()[index];
                 if(!item) return;

                editingFoodLogIndex = index;
                ui.foodNameInput.value = item.name;
                ui.foodServingsInput.value = item.servings;

                const singleServingGrams = (item.grams / item.servings) || 0;
                ui.foodGramsInput.value = singleServingGrams > 0 ? singleServingGrams.toFixed(1) : '';

                document.getElementById('food-calories-input').value = ((item.calories / item.servings) || 0).toFixed(2);
                document.getElementById('food-protein-input').value = ((item.protein / item.servings) || 0).toFixed(2);
                document.getElementById('food-carbs-input').value = ((item.carbs / item.servings) || 0).toFixed(2);
                document.getElementById('food-fat-input').value = ((item.fat / item.servings) || 0).toFixed(2);
                document.getElementById('food-sugar-input').value = ((item.sugar / item.servings) || 0).toFixed(2);
                document.getElementById('food-sodium-input').value = ((item.sodium / item.servings) || 0).toFixed(2);
                document.getElementById('food-potassium-input').value = ((item.potassium / item.servings) || 0).toFixed(2);

                const detailsElement = ui.logMealForm.querySelector('details');
                if (detailsElement) detailsElement.open = true;

                ui.logMealForm.scrollIntoView({ behavior: 'smooth' });
             };

            const handleDeleteLogItem = (index) => {
                showConfirmModal('Delete Log Entry?', 'Are you sure?', () => {
                    let dayLog = getDayLog(viewDate);
                    if (dayLog && dayLog.entries && dayLog.entries[index]) {
                        const itemToDelete = dayLog.entries.splice(index, 1)[0];
                        saveData();
                        fullRender();
                        showUndo('delete', { index, item: itemToDelete });

                        // NEW: Clear form if deleting the item currently being edited
                        if (editingFoodLogIndex === index) {
                            ui.logMealForm.reset();
                            ui.foodServingsInput.value = 1; // Reset servings to 1
                            const detailsElement = ui.logMealForm.querySelector('details');
                            if (detailsElement) detailsElement.open = false; // Close details
                            editingFoodLogIndex = null;
                        }
                    }
                });
            };

            ui.aiDailyReportBtn.addEventListener('click', getDailyLogAIReport);
            ui.closeAiReportModalBtn.addEventListener('click', () => hideModal(ui.aiReportModal));
            ui.aiReportModalOkBtn.addEventListener('click', () => hideModal(ui.aiReportModal));

            ['food-name-input', 'food-brand-input'].forEach(id => document.getElementById(id).addEventListener('input', () => { aiBaseMacros = null; }));

            ui.aiMealSuggesterBtn.addEventListener('click', () => {
                ui.aiSuggestionsOutput.innerHTML = '';
                ui.aiIngredientsInput.value = '';
                showModal(ui.aiSuggesterModal);
            });
            ui.closeAiSuggesterModalBtn.addEventListener('click', () => hideModal(ui.aiSuggesterModal));
            ui.aiSuggestionBtn.addEventListener('click', async () => {
                const btn = ui.aiSuggestionBtn, btnText = btn.querySelector('.btn-text'), loader = btn.querySelector('.loader');
                const ingredients = ui.aiIngredientsInput.value.trim();
                if (!ingredients) { ui.aiSuggestionsOutput.innerHTML = `<p class="text-yellow-400">Please enter some ingredients.</p>`; return; }
                btn.disabled = true; btnText.style.display = 'none'; loader.classList.remove('hidden'); ui.aiSuggestionsOutput.innerHTML = '';
                const currentDayLogEntries = getCurrentDayLogEntries();
                const remainingCalories = Math.max(0, goals.calories - currentDayLogEntries.reduce((sum, item) => sum + item.calories, 0));
                const prompt = `I have: ${ingredients}. I have about ${remainingCalories} calories left. My goal is ${userProfile.goal}. Suggest one simple, healthy meal. Provide the name, prep/cook time, and simple step-by-step instructions. Format with Markdown.`;
                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                const payload = { contents: [{ parts: [{ text: prompt }] }] };
                try {
                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");
                    let text = result.candidates[0].content.parts[0].text;
                    text = text.replace(/\*\*(.*?)\*\*/g, '<h3 class="text-lg font-semibold mt-4 mb-2">$1</h3>').replace(/\*/g, '').replace(/(\d+\.)/g, '<br>$1');
                    ui.aiSuggestionsOutput.innerHTML = `<div class="bg-black/30 p-4 rounded-lg text-sm">${text}</div>`;
                } catch (error) {
                    console.error("AI Suggestion Error:", error);
                    ui.aiSuggestionsOutput.innerHTML = `<p class="text-red-400">Could not get a suggestion. ${error.message}</p>`;
                } finally {
                    btn.disabled = false; btnText.style.display = 'inline'; loader.classList.add('hidden');
                }
            });

            function fileToGenerativePart(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onloadend = () => { const base64Data = reader.result.split(',')[1]; resolve({ inlineData: { mimeType: file.type, data: base64Data } }); }; reader.onerror = (err) => reject(err); reader.readAsDataURL(file); }); }

            async function getAiImageClassification(imagePart) {
                const prompt = "Is this image primarily a barcode or a picture of food? Respond with ONLY 'barcode' or 'food'.";
                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                const payload = { contents: [{ parts: [{ text: prompt }, imagePart] }] };
                try {
                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid classification response.");
                    return result.candidates[0].content.parts[0].text.trim().toLowerCase();
                } catch (error) {
                    console.error("AI Classification Error:", error);
                    return 'error';
                }
            }

            async function processBarcodeScan(decodedText, file, resultElement) {
                const imageUrl = URL.createObjectURL(file);
                resultElement.querySelector('img').src = imageUrl;
                resultElement.querySelector('img').onerror = function() { this.onerror=null; this.src='https://placehold.co/300x150/191919/FFFFFF?text=No+Image'; };

                try {
                    const response = await fetch(`https://world.openfoodfacts.org/api/v2/product/${decodedText}?fields=product_name,brands,nutriments,serving_size,quantity`);
                    if(!response.ok) throw new Error('Product not found in Open Food Facts database.');
                    const data = await response.json();
                    if(data.status === 0 || !data.product) throw new Error(data.status_verbose || 'Product not found.');

                    const product = data.product, nutriments = product.nutriments;
                    const per100g = {
                        calories: nutriments['energy-kcal_100g'] || 0, protein: nutriments.proteins_100g || 0, carbs: nutriments.carbohydrates_100g || 0, fat: nutriments.fat_100g || 0, sugar: nutriments.sugars_100g || 0, sodium: (nutriments.sodium_100g || 0) * 1000, potassium: (nutriments.potassium_100g || 0) * 1000,
                    };

                    let defaultGrams = 100;
                    if (product.serving_size) {
                        const servingMatch = String(product.serving_size).match(/(\d+(\.\d+)?)/);
                        if (servingMatch) { defaultGrams = parseFloat(servingMatch[0]); }
                    } else if (product.quantity) {
                         const quantityMatch = String(product.quantity).match(/(\d+(\.\d+)?)/);
                         if (quantityMatch) { defaultGrams = parseFloat(quantityMatch[0]); }
                    }

                    const productName = capitalizeWords(product.product_name) || 'Scanned Item';

                    const detailsContainer = document.createElement('div');
                    detailsContainer.innerHTML = `
                        <p class="font-bold whitespace-normal">${productName}</p>
                        <p class="text-xs text-gray-400 mb-3">Barcode: ${decodedText}</p>
                        <div class="flex items-center gap-2">
                            <input type="number" value="${defaultGrams.toFixed(0)}" class="form-input !py-1.5 text-center barcode-grams-input" min="0">
                            <span class="text-gray-400">grams</span>
                        </div>
                    `;

                    const logButton = document.createElement('button');
                    logButton.className = 'btn btn-primary !p-2 mt-3 w-full data-log-button';
                    logButton.textContent = 'Log this';
                    logButton.isLogged = false;
                    logButton.logId = null;

                    const gramsInput = detailsContainer.querySelector('.barcode-grams-input');

                    logButton.onclick = () => {
                        const grams = parseFloat(gramsInput.value);
                        if (isNaN(grams) || grams <= 0) {
                            gramsInput.classList.add('!border-red-500');
                            setTimeout(() => gramsInput.classList.remove('!border-red-500'), 1500);
                            return;
                        }

                        if (logButton.isLogged) {
                            // UNLOG
                            const logIndex = getDayLog(viewDate).entries.findIndex(entry => entry.logId === logButton.logId);
                            if (logIndex > -1) {
                                getDayLog(viewDate).entries.splice(logIndex, 1);
                                saveData();
                                updateDayView(viewDate);
                            }
                            logButton.textContent = 'Log this';
                            logButton.classList.remove('btn-secondary');
                            logButton.classList.add('btn-primary');
                            logButton.isLogged = false;
                            logButton.logId = null;
                            gramsInput.disabled = false;
                        } else {
                            // LOG
                            const logId = Date.now();
                            const ratio = grams / 100.0;
                            const foodItem = {
                                logId: logId, name: productName, brand: product.brands || '', servings: 1, grams: grams,
                                calories: (per100g.calories * ratio) || 0, protein: (per100g.protein * ratio) || 0,
                                carbs: (per100g.carbs * ratio) || 0, fat: (per100g.fat * ratio) || 0,
                                sugar: (per100g.sugar * ratio) || 0, sodium: (per100g.sodium * ratio) || 0,
                                potassium: (per100g.potassium * ratio) || 0,
                            };
                            const dayLog = getDayLog(viewDate);
                            dayLog.entries.unshift(foodItem);
                            saveData();
                            updateDayView(viewDate);

                            logButton.textContent = 'Logged! (Tap to undo)';
                            logButton.classList.remove('btn-primary');
                            logButton.classList.add('btn-secondary');
                            logButton.isLogged = true;
                            logButton.logId = logId;
                            gramsInput.disabled = true;

                            // NEW: Populate ingredient row if applicable
                            if (activeRecipeScanBtn) {
                                const row = activeRecipeScanBtn.closest('.ingredient-row');
                                if (row) {
                                    row.querySelector('.ingredient-name').value = productName;
                                    row.querySelector('.ingredient-grams').value = grams.toFixed(0);
                                    row.querySelector('.ingredient-calories').value = foodItem.calories.toFixed(0);
                                    row.querySelector('.ingredient-protein').value = foodItem.protein.toFixed(1);
                                    row.querySelector('.ingredient-carbs').value = foodItem.carbs.toFixed(1);
                                    row.querySelector('.ingredient-fat').value = foodItem.fat.toFixed(1);
                                    row.querySelector('.ingredient-sugar').value = foodItem.sugar.toFixed(1);
                                    row.querySelector('.ingredient-sodium').value = foodItem.sodium.toFixed(0);
                                    row.querySelector('.ingredient-potassium').value = foodItem.potassium.toFixed(0);
                                    updateRecipeTotals();
                                    validateLastRow();
                                }
                                hideModal(ui.foodScannerModal); // Close scanner after populating
                            }
                        }
                    };

                    resultElement.querySelector('.loader')?.remove();
                    resultElement.appendChild(detailsContainer);
                    resultElement.appendChild(logButton);

                } catch (error) {
                    resultElement.querySelector('.loader')?.remove();
                    resultElement.innerHTML += `<p class="text-red-400 text-xs">Error finding barcode data. ${error.message}</p>`;
                }
            }


            async function startAiCamera() {
                ui.foodScannerInitialOptions.classList.add('hidden');
                ui.liveCameraContainer.classList.remove('hidden');
                ui.foodScannerStatus.textContent = 'Starting camera...';
                try {
                    foodCameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
                    ui.foodCameraVideo.srcObject = foodCameraStream;
                    ui.foodScannerStatus.textContent = 'Camera active. Point and capture.';
                } catch (err) {
                    console.error("Camera access error:", err);
                    ui.foodScannerStatus.textContent = 'Could not access camera.';
                    stopAiCamera();
                }
            }

            function stopAiCamera() {
                if (foodCameraStream) {
                    foodCameraStream.getTracks().forEach(track => track.stop());
                }
                foodCameraStream = null;
                ui.liveCameraContainer.classList.add('hidden');
                ui.foodScannerInitialOptions.classList.remove('hidden');
                ui.foodScannerStatus.textContent = '';
            }

            function captureAiPhoto() {
                const video = ui.foodCameraVideo;
                const canvas = ui.foodCameraCanvas;
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const context = canvas.getContext('2d');
                context.drawImage(video, 0, 0, canvas.width, canvas.height);

                canvas.toBlob(blob => {
                    if (blob) {
                        const file = new File([blob], `capture-${Date.now()}.jpg`, { type: 'image/jpeg' });
                        handleAiScanFiles([file]);
                    }
                }, 'image/jpeg', 0.9);
            }

            ui.closeFoodScannerModalBtn.addEventListener('click', () => {
                stopAiCamera();
                hideModal(ui.foodScannerModal);
            });

            ui.startFoodCameraBtn.addEventListener('click', startAiCamera);
            ui.stopFoodCameraBtn.addEventListener('click', stopAiCamera);
            ui.captureFoodPhotoBtn.addEventListener('click', captureAiPhoto);


            async function processFoodImageAI(imagePart, resultElement) {
                try {
                    let prompt = `Identify the food in this image. Respond ONLY with a valid JSON object with these fields: "name", "brand", "servings" (estimated number of standard servings shown), "totalGrams" (estimated total grams for all servings shown), "calories", "protein", "carbs", "fat", "sugar", "sodium", "potassium". The nutritional values (calories, protein, etc.) should be for the TOTAL amount of food pictured.`;

                    const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                    const payload = { contents: [{ parts: [{ text: prompt }, imagePart] }], generationConfig: { responseMimeType: "application/json" } };

                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");

                    const data = JSON.parse(result.candidates[0].content.parts[0].text);
                    resultElement.querySelector('.loader')?.remove();

                    const detailsDiv = document.createElement('div');
                    detailsDiv.className = 'text-xs text-gray-400 whitespace-normal';

                    detailsDiv.innerHTML = `
                        <p class="font-bold text-sm text-white mb-1">${capitalizeWords(data.name) || 'Unknown Food'} (${(data.servings || 1).toFixed(1)} serv.)</p>
                        <p>${data.totalGrams?.toFixed(0) || '?'}g | ${data.calories?.toFixed(0) || '?'} kcal</p>
                        <p>${data.protein?.toFixed(1) || '?'}p | ${data.carbs?.toFixed(1) || '?'}c | ${data.fat?.toFixed(1) || '?'}f</p>
                    `;

                    const logButton = document.createElement('button');
                    logButton.className = 'btn btn-primary !p-2 mt-3 w-full';
                    logButton.innerHTML = 'Log this';
                    logButton.isLogged = false;
                    logButton.logId = null;

                    logButton.onclick = () => {
                         const servings = data.servings || 1;
                         const grams = data.totalGrams || 0;
                         const perServingGrams = servings > 0 ? grams / servings : 0;

                        if (logButton.isLogged) {
                            // UNLOG
                            const logIndex = getDayLog(viewDate).entries.findIndex(entry => entry.logId === logButton.logId);
                            if (logIndex > -1) {
                                getDayLog(viewDate).entries.splice(logIndex, 1);
                                saveData();
                                updateDayView(viewDate);
                            }
                            logButton.textContent = 'Log this';
                            logButton.classList.remove('btn-secondary');
                            logButton.classList.add('btn-primary');
                            logButton.isLogged = false;
                            logButton.logId = null;
                        } else {
                            // LOG
                            const logId = Date.now();
                            const foodItem = {
                                logId: logId, name: capitalizeWords(data.name) || 'Scanned Food', brand: data.brand || '',
                                servings: servings, grams: grams,
                                calories: data.calories || 0, protein: data.protein || 0, carbs: data.carbs || 0, fat: data.fat || 0,
                                sugar: data.sugar || 0, sodium: data.sodium || 0, potassium: data.potassium || 0,
                            };
                            const dayLog = getDayLog(viewDate);
                            dayLog.entries.unshift(foodItem);
                            saveData();
                            updateDayView(viewDate);

                            logButton.textContent = 'Logged! (Tap to undo)';
                            logButton.classList.remove('btn-primary');
                            logButton.classList.add('btn-secondary');
                            logButton.isLogged = true;
                            logButton.logId = logId;

                             // NEW: Populate ingredient row if applicable
                            if (activeRecipeScanBtn) {
                                const row = activeRecipeScanBtn.closest('.ingredient-row');
                                if (row) {
                                    row.querySelector('.ingredient-name').value = foodItem.name;
                                    row.querySelector('.ingredient-quantity').value = foodItem.servings;
                                    row.querySelector('.ingredient-grams').value = foodItem.grams.toFixed(0);
                                    row.querySelector('.ingredient-calories').value = foodItem.calories.toFixed(0);
                                    row.querySelector('.ingredient-protein').value = foodItem.protein.toFixed(1);
                                    row.querySelector('.ingredient-carbs').value = foodItem.carbs.toFixed(1);
                                    row.querySelector('.ingredient-fat').value = foodItem.fat.toFixed(1);
                                    row.querySelector('.ingredient-sugar').value = foodItem.sugar.toFixed(1);
                                    row.querySelector('.ingredient-sodium').value = foodItem.sodium.toFixed(0);
                                    row.querySelector('.ingredient-potassium').value = foodItem.potassium.toFixed(0);
                                    updateRecipeTotals();
                                    validateLastRow();
                                }
                                hideModal(ui.foodScannerModal); // Close scanner after populating
                            }
                        }
                    };
                    resultElement.appendChild(detailsDiv);
                    resultElement.appendChild(logButton);

                } catch (error) {
                    console.error("AI Image Scan Error:", error);
                    resultElement.querySelector('.loader')?.remove();
                     resultElement.innerHTML += `<p class="text-red-400 text-xs">Error analyzing. ${error.message}</p>`;
                }
            }

            async function classifyAndProcessImage(file, resultElement) {
                try {
                    const imagePart = await fileToGenerativePart(file);
                    const classification = await getAiImageClassification(imagePart);

                    if (classification.includes('barcode')) {
                        ui.foodScannerStatus.textContent = 'Barcode detected, scanning...';
                        try {
                            const qrCodeInstance = new Html5Qrcode("barcode-reader-hidden-helper");
                            const decodedText = await qrCodeInstance.scanFile(file, false);
                            qrCodeInstance.clear(); // Ensure scanner resources are released
                            await processBarcodeScan(decodedText, file, resultElement);
                        } catch (err) {
                             console.warn("Local barcode scan failed, falling back to food AI:", err);
                            ui.foodScannerStatus.textContent = 'Barcode scan failed, trying food analysis...';
                            await processFoodImageAI(imagePart, resultElement);
                        }
                    } else if (classification.includes('food')) {
                        ui.foodScannerStatus.textContent = 'Food detected, analyzing...';
                        await processFoodImageAI(imagePart, resultElement);
                    } else {
                        throw new Error("Could not classify image.");
                    }
                } catch (error) {
                     console.error("Image Processing Error:", error);
                    resultElement.querySelector('.loader')?.remove();
                    resultElement.innerHTML += `<p class="text-red-400 text-xs">Scan failed. ${error.message}</p>`;
                }
            }


            function handleAiScanFiles(files) {
                if (!files || files.length === 0) return;
                 ui.foodScannerCarouselWrapper.classList.remove('hidden');
                 ui.scannerResultsContainer.innerHTML = ''; // Clear previous results

                for(const file of files) {
                    const resultElement = document.createElement('div');
                    // FIX 1: Added !flex-shrink-0 to ensure items don't shrink and stay in the single row
                    resultElement.className = 'scroll-item p-4 bg-input-bg rounded-lg text-center !flex-shrink-0';
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        resultElement.innerHTML = `
                            <img src="${e.target.result}" class="w-full h-24 object-cover rounded-md mb-2">
                            <div class="loader mx-auto"></div>
                        `;
                         // Call classifyAndProcessImage *after* the initial HTML is set
                        classifyAndProcessImage(file, resultElement);
                    };
                     reader.onerror = () => { // Handle file read errors
                        resultElement.innerHTML = `<p class="text-red-400 text-xs">Error reading file.</p>`;
                    };
                    reader.readAsDataURL(file);
                    ui.scannerResultsContainer.appendChild(resultElement);
                }
                 // Initial setup/reset of carousel visibility
                 setTimeout(() => {
                    const container = ui.scannerResultsContainer;
                    const scrollLeft = container.scrollLeft;
                    const scrollWidth = container.scrollWidth;
                    const clientWidth = container.clientWidth;
                    ui.foodScannerPrev.style.display = 'none'; // Always hide prev initially
                    ui.foodScannerNext.style.display = scrollWidth > clientWidth + 10 ? 'flex' : 'none';
                 }, 100); // Small delay to allow items to render
            }

            ui.uploadPhotoInput.addEventListener('change', (e) => handleAiScanFiles(e.target.files));

            ui.editFavoriteForm.addEventListener('submit', (e) => {
                e.preventDefault(); const favIndex = favoriteFoods.findIndex(f => f.name === editingFavoriteFoodName); if (favIndex === -1) return;
                const newName = capitalizeWords(document.getElementById('edit-fav-food-name').value.trim());
                if (newName.toLowerCase() !== editingFavoriteFoodName.toLowerCase() && (favoriteFoods.some(f => f.name.toLowerCase() === newName.toLowerCase()) || savedRecipes.some(r => r.name.toLowerCase() === newName.toLowerCase()))) { showCustomAlert('Name Exists', 'A favorite food or recipe with this name already exists.'); return; }
                favoriteFoods[favIndex].name = newName; favoriteFoods[favIndex].calories = parseFloat(document.getElementById('edit-fav-food-calories').value); favoriteFoods[favIndex].protein = parseFloat(document.getElementById('edit-fav-food-protein').value); favoriteFoods[favIndex].carbs = parseFloat(document.getElementById('edit-fav-food-carbs').value); favoriteFoods[favIndex].fat = parseFloat(document.getElementById('edit-fav-food-fat').value);
                 favoriteFoods[favIndex].sugar = parseFloat(document.getElementById('edit-fav-food-sugar')?.value) || 0;
                 favoriteFoods[favIndex].sodium = parseFloat(document.getElementById('edit-fav-food-sodium')?.value) || 0;
                 favoriteFoods[favIndex].potassium = parseFloat(document.getElementById('edit-fav-food-potassium')?.value) || 0;
                saveData(); fullRender(); hideModal(ui.editFavoriteModal);
            });


            // OTHER MODAL LISTENERS
            ui.closeEditFavoriteModalBtn.addEventListener('click', () => hideModal(ui.editFavoriteModal));
            ui.alertModalOkBtn.addEventListener('click', () => hideModal(ui.alertModal));
            ui.confirmModalCancelBtn.addEventListener('click', () => hideModal(ui.confirmModal));
            ui.confirmModalConfirmBtn.addEventListener('click', () => { if (confirmCallback) confirmCallback(); hideModal(ui.confirmModal); });
            ui.promptModalCancelBtn.addEventListener('click', () => { if (promptCallback) promptCallback(null); hideModal(ui.promptModal); });
            ui.promptModalOkBtn.addEventListener('click', () => { if(promptCallback) promptCallback(ui.promptModalInput.value); hideModal(ui.promptModal); });

            ui.openNutritionistChatBtn.addEventListener('click', () => {
                renderChatHistory();
                showModal(ui.aiNutritionistModal);
            });
            ui.closeAiNutritionistModalBtn.addEventListener('click', () => hideModal(ui.aiNutritionistModal));
            ui.aiChatSendBtn.addEventListener('click', handleAiChatSend);
            ui.aiChatInput.addEventListener('keydown', (e) => { if(e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleAiChatSend(); } });

            async function handleAiChatSend() {
                const userInput = ui.aiChatInput.value.trim();
                if(!userInput) return;

                chatHistory.push({ role: "user", parts: [{ text: userInput }] });
                addMessageToChat(userInput, 'user');
                ui.aiChatInput.value = '';
                ui.aiChatSendBtn.disabled = true;
                addMessageToChat('<div class="loader"></div>', 'model', true);

                try {
                    const sevenDaysAgo = new Date();
                    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
                    const recentLogs = Object.entries(allDailyLogs).filter(([date]) => new Date(date) >= sevenDaysAgo);
                    const context = `
                        User Profile: ${JSON.stringify(userProfile)}
                        Nutrition Goals: ${JSON.stringify(goals)}
                        Last 7 Days Food Log: ${JSON.stringify(recentLogs)}
                    `;
                    const systemPrompt = `You are FitTrack AI, a helpful and knowledgeable nutritionist. Analyze the user's provided data to give specific, actionable advice based on their question. Be encouraging and provide clear, concise answers. Here is the user's data context: ${context}`;

                    // FIX 2: Use the new, faster model
                    const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                    const payload = {
                        contents: chatHistory,
                        systemInstruction: { parts: [{ text: systemPrompt }] }
                    };

                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");
                    const aiResponse = result.candidates[0].content.parts[0].text;

                    chatHistory.push({ role: "model", parts: [{ text: aiResponse }] });
                    updateLastMessage(aiResponse.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'));

                } catch(error) {
                    console.error("AI Chat Error:", error);
                    updateLastMessage(`Sorry, I am having trouble connecting right now. ${error.message}`);
                    chatHistory.pop();
                } finally {
                    ui.aiChatSendBtn.disabled = false;
                    saveData();
                }
            }


            function renderChatHistory() {
                if(chatHistory.length === 0) {
                     ui.aiChatHistory.innerHTML = `<div class="text-center text-secondary-text p-4"><i data-lucide="bot" class="w-10 h-10 mx-auto mb-2"></i><p>Hello! I'm your AI Nutritionist. Ask me anything about your diet, food logs, or general nutrition.</p></div>`;
                     lucide.createIcons();
                } else {
                    ui.aiChatHistory.innerHTML = '';
                    chatHistory.forEach(msg => {
                        addMessageToChat(msg.parts[0].text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'), msg.role);
                    });
                }
            }


            function addMessageToChat(message, sender, isLoading = false) {
                 if (chatHistory.length === 1 && sender === 'user') { ui.aiChatHistory.innerHTML = ''; }
                const messageDiv = document.createElement('div');
                messageDiv.className = `p-3 rounded-lg max-w-[85%] ${sender === 'user' ? 'bg-blue-600 self-end' : 'bg-input-bg self-start'}`;
                if(isLoading) messageDiv.id = 'ai-loading-message';
                messageDiv.innerHTML = message;
                ui.aiChatHistory.appendChild(messageDiv);
                ui.aiChatHistory.scrollTop = ui.aiChatHistory.scrollHeight;
            }
             function updateLastMessage(newMessage) {
                const loadingMessage = document.getElementById('ai-loading-message');
                if (loadingMessage) {
                    loadingMessage.innerHTML = newMessage;
                    loadingMessage.removeAttribute('id');
                }
            }

            function handleItemDelete(element) {
                const type = element.dataset.type;
                const index = parseInt(element.dataset.index);
                const name = element.dataset.name;

                if (type === 'log') {
                    handleDeleteLogItem(index);
                } else if (type === 'food' || type === 'recipe') {
                    showConfirmModal(`Delete ${type}?`, `Are you sure you want to delete "${name}"?`, () => {
                        if (type === 'food') {
                            favoriteFoods.splice(index, 1);
                        } else if (type === 'recipe') {
                             showCustomAlert("Action Unavailable", "Recipe deletion is currently disabled.");
                        }
                        saveData();
                        fullRender();
                    });
                }
            }

            function handleItemEdit(element) {
                const type = element.dataset.type;
                const index = parseInt(element.dataset.index);

                if (type === 'log') {
                    handleEditLogItem(index);
                } else if (type === 'food') {
                    const food = favoriteFoods[index];
                    if (!food) return;
                    editingFavoriteFoodName = food.name;
                    document.getElementById('edit-fav-food-name').value = food.name;
                    document.getElementById('edit-fav-food-calories').value = (food.calories || 0).toFixed(2);
                    document.getElementById('edit-fav-food-protein').value = (food.protein || 0).toFixed(2);
                    document.getElementById('edit-fav-food-carbs').value = (food.carbs || 0).toFixed(2);
                    document.getElementById('edit-fav-food-fat').value = (food.fat || 0).toFixed(2);
                document.getElementById('edit-fav-food-sugar').value = (food.sugar || 0).toFixed(2);
                document.getElementById('edit-fav-food-sodium').value = (food.sodium || 0).toFixed(0);
                document.getElementById('edit-fav-food-potassium').value = (food.potassium || 0).toFixed(0);
                showModal(ui.editFavoriteModal);
                } else if (type === 'recipe') {
                     showCustomAlert("Coming Soon", "Recipe editing is currently under development.");
                }
            }

            let pointerStart = { x: 0, y: 0 };
            let currentX = 0;
            let isSwiping = false;
            let swipedElement = null;
            let lastTap = 0;
            let pointerDelta = { x: 0, y: 0 };

            function getPointerCoordinates(e) {
                return e.touches ? { x: e.touches[0].clientX, y: e.touches[0].clientY } : { x: e.clientX, y: e.clientY };
            }

            function handlePointerDown(e) {
                const target = e.target.closest('.swipe-item');
                if (!target || e.target.closest('button, a, input, select, textarea')) return;

                const coords = getPointerCoordinates(e);
                pointerStart.x = coords.x;
                pointerStart.y = coords.y;
                pointerDelta = { x: 0, y: 0 };
                currentX = 0;
                swipedElement = target;
                swipedElement.querySelector('.swipe-content').classList.add('swiping');

                document.addEventListener('mousemove', handlePointerMove);
                document.addEventListener('mouseup', handlePointerUp);
                document.addEventListener('touchmove', handlePointerMove, { passive: false });
                document.addEventListener('touchend', handlePointerUp);
            }

            function handlePointerMove(e) {
                if (!swipedElement) return;

                const coords = getPointerCoordinates(e);
                const deltaX = coords.x - pointerStart.x;
                const deltaY = coords.y - pointerStart.y;
                pointerDelta = { x: deltaX, y: deltaY };

                if (!isSwiping && Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
                    isSwiping = true;
                }

                if (isSwiping) {
                    if (e.cancelable) e.preventDefault();
                    currentX = deltaX;
                    const content = swipedElement.querySelector('.swipe-content');
                    content.style.transform = `translateX(${currentX}px)`;

                    const rightAction = swipedElement.querySelector('.swipe-action-container.right');
                    const leftAction = swipedElement.querySelector('.swipe-action-container.left');

                    if (currentX < 0) {
                        if(rightAction) rightAction.style.opacity = Math.min(1, Math.abs(currentX) / 80).toString();
                        if(leftAction) leftAction.style.opacity = '0';
                    } else {
                        if(leftAction) leftAction.style.opacity = Math.min(1, currentX / 80).toString();
                        if(rightAction) rightAction.style.opacity = '0';
                    }
                }
            }

            function handlePointerUp(e) {
                document.removeEventListener('mousemove', handlePointerMove);
                document.removeEventListener('mouseup', handlePointerUp);
                document.removeEventListener('touchmove', handlePointerMove);
                document.removeEventListener('touchend', handlePointerUp);

                if (!swipedElement) return;

                const elementToClean = swipedElement;
                const content = elementToClean.querySelector('.swipe-content');

                const currentTime = new Date().getTime();
                const isDoubleTap = (currentTime - lastTap) < 300 && !isSwiping;
                lastTap = currentTime;

                const totalDistance = Math.sqrt(pointerDelta.x**2 + pointerDelta.y**2);

                if (isSwiping) {
                    const swipeThreshold = elementToClean.offsetWidth * 0.35;
                    content.classList.add('returning');
                    if (currentX < -swipeThreshold) {
                        handleItemEdit(elementToClean);
                        content.style.transform = 'translateX(0)';
                    } else if (currentX > swipeThreshold) {
                        handleItemDelete(elementToClean);
                    } else {
                        content.style.transform = 'translateX(0)';
                    }
                } else if (totalDistance < 10) { // Only process tap if minimal movement
                    if (isDoubleTap) {
                        const itemName = elementToClean.dataset.name;
                        if (itemName) {
                            toggleFavorite(itemName);
                        }
                    } else if (elementToClean.closest('#saved-items-list')) {
                        // NEW: Handle tap on saved items
                        handleLogSavedItem(elementToClean);
                    }
                }

                isSwiping = false;
                swipedElement = null;
                currentX = 0;
                pointerDelta = { x: 0, y: 0 };

                if (elementToClean && document.body.contains(elementToClean)) {
                    setTimeout(() => {
                        if(content) {
                            content.classList.remove('swiping', 'returning');
                            content.style.transform = '';
                        }
                         const actions = elementToClean.querySelectorAll('.swipe-action-container');
                         if(actions) actions.forEach(el => el.style.opacity = '0');
                    }, 300);
                }
            }

            function handleLogSavedItem(element) {
                const name = element.dataset.name;
                const type = element.dataset.type;
                if (!name || !type) return;

                let itemData;
                let singleServingGrams = 0;
                let singleServingMacros = {};

                if (type === 'food') {
                    itemData = favoriteFoods.find(f => f.name === name);
                    if (!itemData) return;
                    // Favorites are per 100g
                    singleServingGrams = 100;
                    singleServingMacros = {
                        calories: itemData.calories || 0,
                        protein: itemData.protein || 0,
                        carbs: itemData.carbs || 0,
                        fat: itemData.fat || 0,
                        sugar: itemData.sugar || 0,
                        sodium: itemData.sodium || 0,
                        potassium: itemData.potassium || 0,
                    };
                } else if (type === 'recipe') {
                    itemData = savedRecipes.find(r => r.name === name);
                    if (!itemData) return;
                    // Recipes are for 1 serving
                    singleServingGrams = itemData.grams || 0;
                     singleServingMacros = {
                        calories: itemData.calories || 0,
                        protein: itemData.protein || 0,
                        carbs: itemData.carbs || 0,
                        fat: itemData.fat || 0,
                        sugar: itemData.sugar || 0,
                        sodium: itemData.sodium || 0,
                        potassium: itemData.potassium || 0,
                    };
                }

                if (!itemData) return;

                showPromptModal(`Log ${name}`, "How many servings?", "1", (servingsStr) => {
                    if (servingsStr === null) return;
                    const servings = parseFloat(servingsStr);
                    if (isNaN(servings) || servings <= 0) {
                        showCustomAlert("Invalid Amount", "Please enter a valid number of servings.");
                        return;
                    }

                    const totalMacros = {};
                    for (const key in singleServingMacros) {
                        totalMacros[key] = singleServingMacros[key] * servings;
                    }

                    const foodItem = {
                        name: itemData.name,
                        brand: itemData.brand || '',
                        servings: servings,
                        grams: singleServingGrams * servings,
                        ...totalMacros
                    };

                    const dayLog = getDayLog(viewDate);
                    dayLog.entries.unshift(foodItem);
                    saveData();
                    updateDayView(viewDate);
                });
            }

            ui.dailyLogContentDiv.addEventListener('mousedown', handlePointerDown);
            ui.dailyLogContentDiv.addEventListener('touchstart', handlePointerDown, { passive: true });
            ui.savedItemsListDiv.addEventListener('mousedown', handlePointerDown);
            ui.savedItemsListDiv.addEventListener('touchstart', handlePointerDown, { passive: true });

            let daySwipeStart = { x: 0, y: 0 };
            let daySwipeCurrentX = 0;
            let isDaySwiping = false;
            let daySwipeElement = null;

            function handleDaySwipePointerDown(e) {
                const target = e.target.closest('#daily-summary-card');
                if (!target) return;

                const coords = getPointerCoordinates(e);
                daySwipeStart.x = coords.x;
                daySwipeStart.y = coords.y;
                daySwipeCurrentX = 0;
                daySwipeElement = target;

                document.addEventListener('mousemove', handleDaySwipePointerMove);
                document.addEventListener('mouseup', handleDaySwipePointerUp);
                document.addEventListener('touchmove', handleDaySwipePointerMove, { passive: false });
                document.addEventListener('touchend', handleDaySwipePointerUp);
            }

            function handleDaySwipePointerMove(e) {
                if (!daySwipeElement) return;

                const coords = getPointerCoordinates(e);
                const deltaX = coords.x - daySwipeStart.x;
                const deltaY = coords.y - daySwipeStart.y;

                if (!isDaySwiping && Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
                    isDaySwiping = true;
                }

                if (isDaySwiping) {
                    if (e.cancelable) e.preventDefault();
                    daySwipeCurrentX = deltaX;
                    daySwipeElement.style.transition = 'none';
                    daySwipeElement.style.transform = `translateX(${daySwipeCurrentX}px)`;
                }
            }

            function handleDaySwipePointerUp(e) {
                document.removeEventListener('mousemove', handleDaySwipePointerMove);
                document.removeEventListener('mouseup', handleDaySwipePointerUp);
                document.removeEventListener('touchmove', handleDaySwipePointerMove);
                document.removeEventListener('touchend', handleDaySwipePointerUp);

                if (!daySwipeElement) return;

                if (isDaySwiping) {
                    const swipeThreshold = daySwipeElement.offsetWidth * 0.25;

                    daySwipeElement.style.transition = 'transform 0.3s ease';
                    daySwipeElement.style.transform = 'translateX(0)';

                    if (daySwipeCurrentX < -swipeThreshold) {
                        const today = new Date(); today.setHours(0, 0, 0, 0);
                        const nextDay = new Date(viewDate); nextDay.setDate(nextDay.getDate() + 1);
                        if (nextDay.getTime() <= today.getTime()) {
                            viewDate.setDate(viewDate.getDate() + 1);
                            updateDayView(viewDate);
                        }
                    } else if (daySwipeCurrentX > swipeThreshold) {
                        viewDate.setDate(viewDate.getDate() - 1);
                        updateDayView(viewDate);
                    }
                }

                isDaySwiping = false;

                setTimeout(() => {
                    if(daySwipeElement) {
                       daySwipeElement.style.transition = '';
                       daySwipeElement.style.transform = '';
                    }
                    daySwipeElement = null;
                }, 300);
            }

            ui.dailySummaryCard.addEventListener('mousedown', handleDaySwipePointerDown);
            ui.dailySummaryCard.addEventListener('touchstart', handleDaySwipePointerDown, { passive: true });

            const resetToToday = () => {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                updateDayView(today);
            };
            ui.dayViewTitleSpan.addEventListener('click', resetToToday);
            ui.dayViewDateSpan.addEventListener('click', resetToToday);

            ui.undoToastBtn.addEventListener('click', () => {
                if(!lastAction) return;
                const dayLog = getDayLog(viewDate);

                if(lastAction.type === 'delete') {
                    dayLog.entries.splice(lastAction.data.index, 0, lastAction.data.item);
                } else if (lastAction.type === 'edit') {
                    dayLog.entries[lastAction.data.index] = lastAction.data.originalItem;
                } else if (lastAction.type === 'water') {
                    // When undoing water, revert to the state *before* the last action
                    dayLog.water = lastAction.data.originalWater;
                     lastWaterLogAmount = 0; // Prevent re-undoing
                }

                saveData();
                fullRender();
                hideUndo();
            });

            // --- INITIALIZATION ---
            loadData();
            updateDayView(viewDate);
            setupCarousel('ai-scanner-results-container', 'ai-scanner-prev', 'ai-scanner-next');
            // Populate datalist for favorites
            const datalist = document.getElementById('favorite-foods-datalist');
            datalist.innerHTML = favoriteFoods.map(f => `<option value="${f.name}"></option>`).join('');

            // --- Compound Food Modal Initialization ---
            lucide.createIcons({ nodes: [ui.compoundFoodModal.querySelector('.disabled-overlay')] });

            // Open modal button
            ui.openCompoundFoodModalBtn.addEventListener('click', () => {
                showModal(ui.compoundFoodModal);
                lucide.createIcons({ nodes: [ui.compoundFoodModal] });
            });

            // Close modal button
            if (ui.closeCompoundFoodModalBtn && ui.compoundFoodModal) {
                ui.closeCompoundFoodModalBtn.addEventListener('click', () => {
                    hideModal(ui.compoundFoodModal);
                });
            }

            // Event listener to unlock ingredients section
            if (ui.recipeNameInput && ui.ingredientListContainer && ui.addIngredientBtn) {
                ui.recipeNameInput.addEventListener('input', () => {
                    const hasName = ui.recipeNameInput.value.trim() !== '';
                    if (hasName) {
                        ui.ingredientListContainer.classList.remove('section-disabled');
                        validateLastRow();
                    } else {
                        ui.ingredientListContainer.classList.add('section-disabled');
                        ui.addIngredientBtn.disabled = true;
                    }
                });
            }

            // "Add Ingredient" button click
            if (ui.addIngredientBtn) {
                ui.addIngredientBtn.addEventListener('click', () => {
                    addIngredientRow();
                });
            }

            // Event listener for "Remove" button, AI lookup, and scan within ingredient rows
            if (ui.ingredientListContainer) {
                ui.ingredientListContainer.addEventListener('click', async (e) => {
                    const removeBtn = e.target.closest('.remove-ingredient-btn');
                    const aiBtn = e.target.closest('.find-macros-ai-btn');
                    const scanBtn = e.target.closest('.recipe-scan-btn'); // Get scan button
                    const row = e.target.closest('.ingredient-row');

                    if (removeBtn && row) {
                        if (ui.ingredientListContainer.querySelectorAll('.ingredient-row').length > 1) {
                            row.remove();
                            updateIngredientNumbers();
                        } else {
                            row.querySelectorAll('input').forEach(input => {
                                if (input.classList.contains('ingredient-quantity')) {
                                    input.value = '1';
                                } else {
                                    input.value = '';
                                }
                            });
                        }
                        updateRecipeTotals();
                        validateLastRow();
                    }

                    if (aiBtn && row) {
                        e.preventDefault();
                        if (aiBtn.disabled) return;
                        const loader = aiBtn.querySelector('.loader');
                        const icon = aiBtn.querySelector('.lucide-icon');
                        const recipeName = ui.recipeNameInput.value.trim();
                        const ingredientData = {
                            quantity: row.querySelector('.ingredient-quantity').value.trim(),
                            name: row.querySelector('.ingredient-name').value.trim(),
                            grams: row.querySelector('.ingredient-grams').value.trim(),
                            calories: row.querySelector('.ingredient-calories').value.trim(),
                            protein: row.querySelector('.ingredient-protein').value.trim(),
                            carbs: row.querySelector('.ingredient-carbs').value.trim(),
                            fat: row.querySelector('.ingredient-fat').value.trim(),
                            sugar: row.querySelector('.ingredient-sugar').value.trim(),
                            sodium: row.querySelector('.ingredient-sodium').value.trim(),
                            potassium: row.querySelector('.ingredient-potassium').value.trim()
                        };
                        if (!ingredientData.name) { return; }
                        if (row.abortController) { row.abortController.abort(); }
                        const controller = new AbortController();
                        row.abortController = controller;
                        row.dataset.loading = 'true';
                        aiBtn.disabled = true;
                        loader.classList.remove('hidden');
                        icon.classList.add('hidden');
                        try {
                            const data = await fetchIngredientMacros(recipeName, ingredientData, controller.signal);
                            row.querySelector('.ingredient-grams').value = data.grams.toFixed(0);
                            row.querySelector('.ingredient-calories').value = data.calories.toFixed(0);
                            row.querySelector('.ingredient-protein').value = data.protein.toFixed(1);
                            row.querySelector('.ingredient-carbs').value = data.carbs.toFixed(1);
                            row.querySelector('.ingredient-fat').value = data.fat.toFixed(1);
                            row.querySelector('.ingredient-sugar').value = data.sugar.toFixed(1);
                            row.querySelector('.ingredient-sodium').value = data.sodium.toFixed(0);
                            row.querySelector('.ingredient-potassium').value = data.potassium.toFixed(0);
                            updateRecipeTotals();
                        } catch (error) {
                            if (error.name !== 'AbortError') { console.error("AI Macro Search Failed:", error); }
                        } finally {
                            aiBtn.disabled = false;
                            loader.classList.add('hidden');
                            icon.classList.remove('hidden');
                            delete row.abortController;
                            delete row.dataset.loading;
                        }
                    }

                    // UPDATED: Handle recipe scan button click
                     if (scanBtn && row) {
                        activeRecipeScanBtn = scanBtn; // Store the button that was clicked
                        ui.scannerResultsContainer.innerHTML = ''; // Clear previous scan results
                        ui.foodScannerStatus.textContent = '';
                        ui.liveCameraContainer.classList.add('hidden');
                        ui.foodScannerInitialOptions.classList.remove('hidden');
                        ui.foodScannerCarouselWrapper.classList.add('hidden');
                        showModal(ui.foodScannerModal); // Show the main scanner modal
                    }

                });

                // Add live calculation and validation listener
                ui.ingredientListContainer.addEventListener('input', (e) => {
                    if (e.target.type === 'number' && parseFloat(e.target.value) < 0) {
                        e.target.value = ''; // Clear negative input
                    }
                    updateRecipeTotals();
                    validateLastRow();
                });
            }

            // Carousel Logic for Recipe Ingredients
            if (ui.ingredientListContainer && ui.recipeCarouselPrev && ui.recipeCarouselNext) {
                const scrollAmount = () => {
                    const firstItem = ui.ingredientListContainer.querySelector('.scroll-item');
                    // Ensure full width scroll for ingredients
                    return firstItem ? firstItem.offsetWidth + 16 : 300; // Use offsetWidth + gap
                };

                ui.recipeCarouselPrev.addEventListener('click', () => {
                    ui.ingredientListContainer.scrollBy({ left: -scrollAmount(), behavior: 'smooth' });
                });

                ui.recipeCarouselNext.addEventListener('click', () => {
                    ui.ingredientListContainer.scrollBy({ left: scrollAmount(), behavior: 'smooth' });
                });

                 // Add scroll listener to show/hide buttons for recipe carousel
                 ui.ingredientListContainer.addEventListener('scroll', () => {
                    const scrollLeft = ui.ingredientListContainer.scrollLeft;
                    const scrollWidth = ui.ingredientListContainer.scrollWidth;
                    const clientWidth = ui.ingredientListContainer.clientWidth;

                    ui.recipeCarouselPrev.style.display = scrollLeft > 10 ? 'flex' : 'none';
                    ui.recipeCarouselNext.style.display = scrollLeft < scrollWidth - clientWidth - 10 ? 'flex' : 'none';
                });

                // Initial check for recipe carousel buttons
                setTimeout(() => {
                    const scrollWidth = ui.ingredientListContainer.scrollWidth;
                    const clientWidth = ui.ingredientListContainer.clientWidth;
                    ui.recipeCarouselPrev.style.display = 'none'; // Prev always hidden initially
                    ui.recipeCarouselNext.style.display = scrollWidth > clientWidth + 10 ? 'flex' : 'none';
                }, 100);
            }

            // Load Initial Ingredient
            addIngredientRow();
            updateRecipeTotals();
            validateLastRow();
            // --- END: Compound Food Modal Initialization ---

        });
    </script>
</body>
</html>
